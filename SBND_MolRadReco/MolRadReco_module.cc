////////////////////////////////////////////////////////////////////////
// Class:       MolRadReco
// Plugin Type: analyzer (art v2_07_03)
// File:        MolRadReco_module.cc
//SBND
//
// Generated at Fri Aug 11 12:10:37 2017 by Dylan White using cetskelgen
// from cetlib version v3_00_01.

// Modified by Krishan Mistry 11-10-2017 e: krishan.mistry-5@postgrad.manchester.ac.uk

////////////////////////////////////////////////////////////////////////

// Default art includes
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Optional/TFileService.h"

// LARSOFT includes
#include "lardataobj/Simulation/SimChannel.h" //
#include "lardataobj/Simulation/SimPhotons.h" //
#include "lardataobj/Simulation/AuxDetSimChannel.h" //
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"     //
//#include "lardata/DetectorInfo/DetectorPropertiesStandard.h"          // Commented out as causing a error when building
#include "larsim/Simulation/LArG4Parameters.h"                          //
#include "larcore/Geometry/Geometry.h" //
#include "larreco/Calorimetry/CalorimetryAlg.h" //
#include "lardataobj/RecoBase/Hit.h" //
#include "larreco/Calorimetry/CalorimetryAlg.h" 			            // For dEdx conversion
#include "larreco/RecoAlg/ClusterRecoUtil/ClusterParamsAlg.h"		    // for cluster params alg function 
#include "larevt/CalibrationDBI/Interface/ElectronLifetimeService.h"    // For dEdx conversion
#include "larevt/CalibrationDBI/Interface/ElectronLifetimeProvider.h"   // For dEdx conversion

#include "nutools/ParticleNavigation/ParticleList.h" //
#include "nutools/ParticleNavigation/EmEveIdCalculator.h" //
#include "larcoreobj/SimpleTypesAndConstants/geo_types.h" //

//#include "nusimdata/SimulationBase/MCTrajectory.h" // for MCtrajectroy

// ROOT includes
#include "TH1.h" 
#include "TH2.h" 
#include "TH3.h" 
#include "TTree.h" 
#include "TDatabasePDG.h" 
#include "TParticlePDG.h" 
#include "TCanvas.h" 
#include "TVectorT.h" 
#include "TMatrixT.h" 
#include "TMatrixDUtils.h" 
#include "TGraph.h" 
#include "TF1.h" 
#include "TMath.h"

// C++ Includes
#include <cmath>
#include <map>
#include <iostream>
#include <algorithm>

#define PI 3.14159265

// Global Definitions
TVectorD vSOSA(2), vPCA(2);	// Axis Angles
typedef std::vector<const sim::SimChannel*> simChannelVec_t; // SimChannel Vector

// This structure stores the energy,position and index of events
class entry {
public:
	TVectorD position;
	double energy;
	int primInd;	// used only for PCA (NOTE this isn't actually needed in the entry struct, it's the same for all entries in an event. This can be changed later, but probably won't speed it up a huge amount.)
	bool operator <(const entry& rhs) {	// compare final element for SOSA sorting (should only be n=2 currently)
		return position[position.GetNoElements()-1] < rhs.position[rhs.position.GetNoElements()-1];
	}
};

class MolRadReco;

class MolRadReco : public art::EDAnalyzer {
public:
  explicit MolRadReco(fhicl::ParameterSet const & p);
  // The compiler-generated destructor is fine for non-base
  // classes without bare pointers or other resource use.

  // Plugins should not be copied or assigned. Automatically generated by program
  MolRadReco(MolRadReco const &) = delete;
  MolRadReco(MolRadReco &&) = delete;
  MolRadReco & operator = (MolRadReco const &) = delete;
  MolRadReco & operator = (MolRadReco &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Selected optional functions. Automatically generated
  void beginJob() override;
  void endJob() override;
  
  // custom functions
  void   addDataEntry(double energy, TVectorD position); 					 // Creates a struct of type entry which contains energy, position and index. 
  void   clearDataEntries(bool cleartree);
  void   runPCA();															 // Principal Component Analysis
  void   runSOSA(double cm);												 // Start of Shower Alignment
  double Containment(double energySum, TH1D *h , std::string Type); 		 // Funtion that calculates the containment in the Trans and Longitudinal Directions
  double GetTruthXYZE(simChannelVec_t simChannelVec, bool use3D, int event); // Function that gets the truth quantities of a hit and pushes them into a vector
  double GetRecoXYZE(art::Event const & event, double dEnergySum ); 		 // Function that gets the reconstructed quantities of a hit and pushes them into a vector

private:
	// parameters from the .fcl file.
	std::string fSimulationProducerLabel;			// The name of the producer that tracked simulated particles through the detector
	std::vector<std::string> fHitProducerLabel;     // The name of the producer that created hits
	art::ServiceHandle<geo::Geometry> fGeometry;	// pointer to Geometry service
	calo::CalorimetryAlg  fCalorimetryAlg;          // Calorimetry Alg to convert to ADC*Ticks to dEdx
	//cluster::ClusterParamsAlg  fClusterParamsAlg; // Cluster params alg implementaion. 
	
	// Position Histograms
	TH2D* hPosition2D, *hPosition2DSOSA, *hPosition2DPCA, *hTruePosition2D, *hTruePosition2DSOSA, *hTruePosition2DPCA;
	
	// Energy Profiles
	TH1D* hEnergyProfilePCA, *hEnergyProfile, *hTrueEnergyProfile, *hTrueEnergyProfileX, *hTrueEnergyProfileR;

	// Moliere Radius
	TH1D* hMolRadHitPCA, *hMolRadHitSOSA, *hMolRadTruthPCA2D, *hMolRadTruthSOSA2D, *hMolRadTruthPCA3D, *hMolRadTruth2D, *hMolRadTruth3D;
	
	// Moliere Radius Correlation plots
	TH2D* hMolRadCorrelation2Dh2Dt, *hMolRadCorrelation2Dh3DtPCA, *hMolRadCorrelation2Dh3DtSOSA, *hMolRadCorrelation2Dt3Dt, *hMolRadCorrelationSOSA2Dh2Dt;
	
	TGraph* gCorr_2Dt_3Dt;	// TGraph for 2D truth vs 3D truth for conversion factor
	
	// Normalised Correlation Plots
	TH2D* hMolRadCorrelation2Dh2DtNorm, *hMolRadCorrelation2Dh3DtPCANorm, *hMolRadCorrelation2Dh3DtSOSANorm, *hMolRadCorrelation2Dt3DtNorm, *hMolRadCorrelationSOSA2Dh2DtNorm;
	
	// Other Graphs
	TH1D* 	hPCASOSAAngle;					// for debugging 3D PCA
	TH1D*	hEnergyFraction;				// for seeing if full Mol Rad calculation is feasible
	TH1D* 	hMolRadConvertedPCA;			// test output histogram for converted Mol. Rad. values	
	TH1D* 	hdEdxValues;					// Histogram of the dEdx values for a muon for energy calibration check
	TGraph* gECalScat; 						// Scatter plot of dEdx vs dQdx for energy calibration
	TF1* 	ECalScatFit; 					// Fit function for the ECal Scat graph
	TH2D* 	hERecoTruthScat; 				// Scatter plot of the reco to truth energy (muons only)
	TF1* 	TruthRecoScatFit;               // Fit function for truth reco scatter plot
	TH1D* 	hERecoTruthDiff; 				// Histogram of the difference between reco and truth energy
	TF1* 	ERecoTruthDiffFit;              // Fit for reco-truth difference.
	TH1D* 	hEnergyDetected;				// Total amount of energy detected in an event
	TGraph* TruthRecoScat;             		// Scatterplot of truth vs reco+correction energy
	TH1D* 	hPerpDist;						// Histogram used for calculating moliere radius

	// Doubles	
	double pitch = 0.3 ;	        		// 3 mm wire spacing in SBND
	double dEnergySumTotal;		        	// total energy over all events
	double dEnergyDepositedSum; 
	double PCA_E_Total= 0.;
	double Truth_E_Total;

	// Integers
	int fills = 0;	
	int HistFill = 999; 					// Number to decide if to fill a histogram or not (avoids overfilling truth position 2D)

	// Type Definitions
	typedef TMatrixT<double> TMatrixD;
	
	// Vectors
	std::vector<double> RecoEnergyVector, TruthEnergyVector;
	std::vector<double> vdQdx, vdEdx; 		// Vectors for making the scatter plot of dQ/dx against dE/dx
	std::vector<entry> 	vEntries; 			// To store the hit position and energy	
	

	// TTree Variables
	TTree* DataTree; 
    int run, subrun, evt;
    std::vector<double> TruthEnergyDeposits, TruthZPos, TruthXPos;
    //std::vector<double> Reco_E, Reco_ZPos, Reco_XPos; // Vectors containing Reconstructed parameters
	//std::vector<double> PCA_XPos, PCA_ZPos; // Vectors containing PCA parameters

	// Histograms for calculating the Moliere radius over all events for different cases. 
	TH1D* hReco_PerpDist_2D_All = 		new TH1D("hReco_PerpDist_2D_All", "Title",		1000,0.,100.);
	TH1D* hReco_PerpDist_2D_PCA_All = 	new TH1D("hReco_PerpDist_2D_PCA_All", "Title",  1000,0.,100.);
	TH1D* hReco_PerpDist_2D_SOSA_All = 	new TH1D("hReco_PerpDist_2D_SOSA_All", "Title", 1000,0.,100.);
	TH1D* hTruth_PerpDist_2D_All = 		new TH1D("hTruth_PerpDist_2D_All", "Title", 	1000,0.,100.);
	TH1D* hTruth_PerpDist_2D_PCA_All = 	new TH1D("hTruth_PerpDist_2D_PCA_All", "Title", 1000,0.,100.);
	TH1D* hTruth_PerpDist_2D_SOSA_All = new TH1D("hTruth_PerpDist_2D_SOSA_All", "Title",1000,0.,100.);
	TH1D* hTruth_PerpDist_3D_All = 		new TH1D("hTruth_PerpDist_3D_All", "Title", 	1000,0.,100.);
	TH1D* hTruth_PerpDist_3D_PCA_All = 	new TH1D("hTruth_PerpDist_3D_PCA_All", "Title", 1000,0.,100.);

	// Fits	
	TF1* TProfFit = new TF1("TProfFit","[2]*[0]/([1]*(x-[3])*(x-[3]) + [0]*[0]) + gaus(4) ",10., 10.); // Lorenzian
	TF1* TProfFit_Radial = new TF1("TProfFit_Radial"," landau ",0., 20.); // Fit function for energy prifile
	TF1* TrueEnergyProfileFit = new TF1("TrueEnergyProfileFit", "[AMP]* ROOT::Math::gamma_pdf(x , [ALPHA] , [THETA], [MU]) ",8., 250.); // Fit function for energy prifile in longitudinal direction
	
};

void MolRadReco::addDataEntry(double energy, TVectorD position) {
	// check entry validity
	bool addEntry = true;
	if (vEntries.size() > 0) { //check the vector is not empty (vEntries is a vector of entries)
		if (!(vEntries[0].position.GetNoElements() == position.GetNoElements())) { //checks that the position vector dimentions are compatable
			addEntry = false; // not equal so throw error
			std::cout << "Could not add PCA entry - incorrect position vector dimensions" << std::endl;
		}
	}
	if (energy < 0.) { // check for energies less than zero
		addEntry = false;
		std::cout << "Could not add PCA entry - invalid energy value (< 0)" << std::endl;
	}

	// A valid entry has been found so add to vEntries
	if (addEntry) {
		entry e;  
		e.position.ResizeTo(position); // resizes the position vector to the input position  vector size
		e.position = position; // add the position
		e.energy = energy;     // add the energy
		e.primInd = -25;	//** placeholder - can use for checks later. 
		vEntries.push_back(e);

	}

	return;
}

void MolRadReco::clearDataEntries(bool cleartree) {
	vEntries.clear();
	TruthEnergyDeposits.clear();
	TruthZPos.clear();
	TruthXPos.clear();

	//  Clear all the Tree Variables
	if (cleartree ==true){
		
		//Reco_E.clear();
		//Reco_XPos.clear();
		//Reco_ZPos.clear();
		//PCA_E.clear();
		//PCA_XPos.clear();
		//PCA_ZPos.clear();

	}

	return;
}

void MolRadReco::runPCA() {
	
	// Definitions
	int dim = vEntries[0].position.GetNoElements(); // Number of dimentions - 2 or 3
	int N = vEntries.size(); 
	int iPrimaryIndex;
	double dEnergySqSum = 0;
	
	// Vectors
	TVectorD vMean(dim);
	TVectorD vCoords(dim);
	TVectorD vEigval(dim);
	TMatrixD mEigvec(dim, dim); // The largest eigenvector points in the direction of the PCA axis (2x2 matrix)
	TMatrixD mCovariance(dim, dim);
	mCovariance = 0.;
		
	// loop 1 - calculate means, energy (sq) sums
	for(int i = 0; i < N; i++) {
		// calculate mean positions
		for (int x = 0; x < dim; x++) {
			vMean[x] += vEntries[i].position[x]; // Sums the positions for x and z (and y) to vector vMean
		}
		// calculate energy (sq) sums
		dEnergySqSum += std::pow(vEntries[i].energy, 2);
	}
	vMean *= 1./((double) N); 


	// loop 2 - fill covm
	for(int i = 0; i < N; i++) {
		// fill Covariance matrix
		for (int b = 0; b < vMean.GetNoElements(); b++) { // vMean.GetNoElements() = 2 or 3
			for (int a = 0; a < vMean.GetNoElements(); a++) {
				mCovariance(a,b) += (vEntries[i].position[a] - vMean[a])*(vEntries[i].position[b] - vMean[b])*std::pow(vEntries[i].energy, 2);
			}
		}
	}
	
	// finish Covariance matrix calculation
	mCovariance *= 1./((hPosition2D->GetEntries() - 1.)*dEnergySqSum); // Calculates the equation of sigmaxy in dylans report
	
	// Get eigenvecs/vals, and transpose eigenvecs matrix
	mEigvec = mCovariance.EigenVectors(vEigval); // Also fills supplied vector with Eigenvalues
	mEigvec.Transpose(mEigvec);					 // Transpose
	
	// Get primary eigenvector - the one with the largest eigenvalue - indexes the PCA axis vector
	iPrimaryIndex = 0;
	for (int i = 1; i < dim; i++) {
		if (std::abs(vEigval[i]) > std::abs(vEigval[iPrimaryIndex])) {
			iPrimaryIndex = i;
		}
	}

	// Look at the primary index
	//std::cout << "The PCA Primary Index is: " << iPrimaryIndex << std::endl;
	
	// If the primary eigenvector is negative (Z < 0) then flip its direction
	if (mEigvec(iPrimaryIndex, dim - 1) < 0.) {
		mEigvec *= -1.;
		//std::cout << "Negative eigenvector -> Flipping the Eigenvector sign..." << std::endl;
	}

	// loop 3 - transform coordinates, save primary index coords, find lowest Z
	int iLowestZ = 0;
	for(int i = 0; i < N; i++) {
		vEntries[i].position -= vMean; 			// Subtract the mean
		vEntries[i].position *= mEigvec; 		// Transform to PCA eigenvector basis - Should now align the shower horizontally
		vEntries[i].primInd = iPrimaryIndex; 	// Sets the PCA axis vector index for all coordinates

		// Finds the lowest Z value (to shift to the starting point of the shower Z=0)
		if (vEntries[i].position[iPrimaryIndex] < vEntries[iLowestZ].position[iPrimaryIndex]) {
			iLowestZ = i;
		}
	}

	
	// loop 4 - shift coordinates to start at lowest X;
	double dZShift = vEntries[iLowestZ].position[iPrimaryIndex];
	for(int i = 0; i < N; i++) {
		vEntries[i].position[iPrimaryIndex] -= dZShift;
	}
	
	// fill vector check
	if (dim == 2) {
		vPCA[0] = mEigvec(iPrimaryIndex, 1); // X
		vPCA[1] = mEigvec(iPrimaryIndex, 0); // Z
	}
	
	// Output the PCA axis vector and the angle to the beam direction (Z)
	//std::cout << "("<<  mEigvec(iPrimaryIndex, 1) << ", "<< mEigvec(iPrimaryIndex, 0)<< ")"<< std::endl;
	//std::cout << "Angle: " << (180 / PI)* std::atan(vPCA[1]/vPCA[0]) << std::endl;	
	return;
}

void MolRadReco::runSOSA(double cm) {
	// N.B. this is only for 2D
	//cm =15.;
	
	// initial checks
	if (vEntries[0].position.GetNoElements() != 2) {
		std::cout << "Could not run SOSA - needs 2D positions" << std::endl;
		return;
	}
	
	// consts
	int N = vEntries.size();
	
	// find left-most entry
	int iZMin = 0;
	for (int i = 1; i < N; i++) {
		if (vEntries[i].position[1] < vEntries[iZMin].position[1]) {
			iZMin = i;
		}
	}
	

	//if( vEntries[1].position[1] + cm < 20.) std::cout << "  \n\n\n\n  " << vEntries[1].position[1] + cm <<  "  \n\n\n\n  " << std::endl;
	

	// Put points into a graph that are less than cm (Specified Distance)
	std::vector<double> a; a.clear();
	std::vector<double> b; b.clear();
	for (int i = 0; i < N; i++) {
		if (vEntries[i].position[1] <  vEntries[i].position[1] + cm && vEntries[i].position[1] > 0. ) {  // temporary fix, changed vEntries[1].position[1] + cm -> cm

			a.push_back(vEntries[i].position[1]);	// Z
			b.push_back(vEntries[i].position[0]);	// x
		}
	}
	TGraph* gr = new TGraph(a.size(), &a[0], &b[0]); // Create graph
	
	// BREAK THE FUNCTION IF NOT ENOUGH POINTS FOR A LINEAR FIT
	if (a.size() <= 3) {
		std::cout << "Not enough points for linear fit. Skipping..." << std::endl;
		clearDataEntries(false);
		return;
	}
	
	// Fit 2D line to these points - fit("pol1") "y = p1 * x + p0"
	gr->Fit("pol1", "Q");
	TF1 *fit = gr->GetFunction("pol1");
	double p0 = fit->GetParameter(0);
	double p1 = fit->GetParameter(1);
	
	double z0 = vEntries[iZMin].position[1];
	double x0 = p0 + p1*z0;


	z0 = vEntries[1].position[1]; // Redefined the x0 and z0 positions to avoid data point too far to the left. 
	x0 = vEntries[1].position[0];
	
	
	//double ctheta = 1./std::sqrt(1. + std::abs(p1 * cm)/std::pow(cm - z0,2) ); // temp code for improved SOSA
	//double stheta = std::sqrt(1. - std::pow(ctheta,2) );

	//double test= (p1 * cm)/std::pow(cm - z0,2) ;

	//std::cout << "costheta: " << ctheta << "\nstheta:: "<< stheta  << "\np1: " << p1 <<std::endl;

	//if (p1 < 0.) stheta = stheta* -1.; // if the shower is pointing in the opposite direction then rotate the other way.

	//std::cout << "p0: " << p0<< "\np1: "<< p1 << "\nz0: "<< z0 <<"\ny0:  " << x0 << "\nvEntries[10].position[1]: " << vEntries[10].position[1] << "\nvEntries[10].position[0]: "  << vEntries[10].position[0]<< std::endl;

	// Then calculate perpendicular distances from this line
	for (int i = 0; i < N; i++) {
		double z = vEntries[i].position[1];
		double x = vEntries[i].position[0];
		double xp = (p0 + p1*z - x)/std::sqrt(1 + p1*p1);
		double zp = std::sqrt(std::pow(z-z0,2) + std::pow(x-x0,2) - std::pow(xp,2));
		vEntries[i].position[1] = zp;
		vEntries[i].position[0] = xp;
		//vEntries[i].position[1] = z * ctheta + x * stheta - z0 ; // z prime 
		//vEntries[i].position[0] = x * ctheta - z * stheta - x0;  // x prime

		vEntries[i].primInd = 1;
	}

	//std::cout << "\n\nCorrected\np0: " << p0<< "\np1: "<< p1 << "\nz0: "<< z0 <<"\ny0:  " << x0 << "\nvEntries[10].position[1]: " << vEntries[10].position[1] << "\nvEntries[10].position[0]: "  << vEntries[10].position[0]<< std::endl;
	
	// fill vector check
	vSOSA[0] = 1./std::sqrt(1. + p1*p1); // X
	vSOSA[1] = p1/std::sqrt(1. + p1*p1); // Z
	
	//std::cout << "Finished SOSA" << std::endl;
	
	return;
}

// Function to calculate the containment of a shower in the transverse and lonigtudinal directions. 
double MolRadReco::Containment(double energySum, TH1D *h, std::string Type) {

	int iNbins = h->GetNbinsX(); // Gets the total number of x-bins for the histogram h
	int iBinUpper = 0;
	double dIntegral = 0.;
	double Range = 0.; 			// The integral range

	if 		(Type == "T")  Range = 0.9; 	// For Moliere radius
	else if (Type == "T2") Range = 0.95; 	// For 2x Moliere Radius
	else if (Type == "L")  Range = 0.95;  	// For Longitudingal Containment	

	// Check if the integral of the charge agrees with the summed energy
	if (std::abs(1 - (h->Integral(0, iNbins+1)/energySum)) < 0.001) { // calculate integral-to-total-energy ratio (include mean energy deposit energy to convert counts to energy)

		// Calculate Containment up to Range
		while (dIntegral < Range * energySum) {
			iBinUpper++;
			dIntegral = h->Integral(0, iBinUpper);
		}

		 //std::cout << "Calculated Moliere Radius in test function: " << h->GetBinLowEdge(iBinUpper) << std::endl;
		return h->GetBinLowEdge(iBinUpper);

	} 
	else {
		std::cout << "Integral and Counted energies do not agree (" << (h->Integral(0, iNbins+1)/energySum) << ")" << std::endl;
		return -25;	// debug value
	}
}

// Default constructor for MolradReco
MolRadReco::MolRadReco(fhicl::ParameterSet const & p): EDAnalyzer(p), fCalorimetryAlg(p.get<fhicl::ParameterSet>("CaloAlg")) {

	fSimulationProducerLabel = p.get< std::string >("SimulationLabel");
	fHitProducerLabel = p.get< std::vector< std::string > >("HitLabel");
	//fClusterParamsAlg = p.get<fhicl::ParameterSet>("ClusterAlg");
} 

// Function gets the truth x, y z and energy. Also returns the total Energy deposited
double MolRadReco::GetTruthXYZE(simChannelVec_t simChannelVec, bool use3D, int event){
	
	double dEnergyDepositedSum = 0.; // total amount of deposited energy

	// loop over channels
	for( simChannelVec_t::const_iterator channelPtr = simChannelVec.begin(); channelPtr != simChannelVec.end(); ++channelPtr ) {
		// get individual channel
		const sim::SimChannel& channel = *(*channelPtr);
		
		// select plane 0
		if ( fGeometry->SignalType(channel.Channel()) == geo::kCollection ) {
			// get time slice
			const sim::SimChannel::TDCIDEs_t& timeSlices = channel.TDCIDEMap();
			
			// loop over time slices
			for( sim::SimChannel::TDCIDEs_t::const_iterator timePtr = timeSlices.begin(); timePtr != timeSlices.end(); ++timePtr ) {
				
				// get vector of IDEs (second entry in map<first,second>)
				typedef std::vector<sim::IDE> depositVec_t;
				const depositVec_t& energyDeposits = (*timePtr).second;
				
				// loop over IDEs
				for( depositVec_t::const_iterator energyPtr = energyDeposits.begin(); energyPtr != energyDeposits.end(); ++energyPtr ) {
					// get IDE
					const sim::IDE& energyDeposit = (*energyPtr);
					TruthEnergyDeposits.push_back(energyDeposit.energy);
					TruthZPos.push_back(energyDeposit.z - 250.);   // add z pos to a tree
					TruthXPos.push_back(energyDeposit.x - 102.5); // add xpos to tree

					
					// Add hit coordinates to PCA vectors					
					
					if (use3D == true) {
						TVectorD vHitPos(3);
						vHitPos[0] = energyDeposit.x - 102.5;	// X
						vHitPos[1] = energyDeposit.y;	        // Y
						vHitPos[2] = energyDeposit.z - 250.;	// Z

						//if (vHitPos[2] > 0. ) {addDataEntry(energyDeposit.energy, vHitPos); dEnergyDepositedSum += energyDeposit.energy;} // delete any spurious data points (z<0) and add the entries to the vector
						
						// Use this block as opposed to above if want to use LArIAT geometry
						if (vHitPos[2] > 0. && vHitPos[2] < 90. && vHitPos[0] < 47. && vHitPos[1] < 40. && vHitPos[0] > -47. && vHitPos[1] > -40. ) {
							addDataEntry(energyDeposit.energy, vHitPos); dEnergyDepositedSum += energyDeposit.energy;
						} 

					} else { // 2D case
						
						TVectorD vHitPos(2);
						vHitPos[0] = energyDeposit.x - 102.5;	// X
						vHitPos[1] = energyDeposit.z - 250.;	// Z
						
						//if (vHitPos[1] > 0.) { addDataEntry(energyDeposit.energy, vHitPos); dEnergyDepositedSum += energyDeposit.energy; } // delete any spurious data points (z<0) and add the entries to the vector
						
						// Use this block as opposed to above if want to use LArIAT geometry
						if (vHitPos[1] > 0. && vHitPos[1] < 90. && vHitPos[0] < 47. && vHitPos[0] > -47. ) { 
							addDataEntry(energyDeposit.energy, vHitPos); dEnergyDepositedSum += energyDeposit.energy; 
						} // delete any spurious data points (z<0) and add the entries to the vector

						// Fill the 2D position histogram
						if (HistFill != event) { 
							hTruePosition2D->Fill(vHitPos[1], vHitPos[0], energyDeposit.energy);
						}
						
					}
							
				} // End loop over energy deposits (IDEs)


			} // End loop over Time slices

		} // End condition if in collection plane

	} // End loop over all channels
	HistFill = event; // Dont fill this histogram again
	return dEnergyDepositedSum; 
}

double MolRadReco::GetRecoXYZE(art::Event const & event,  double dEnergySum ){
	
	// hitHandle: Holds hit information
	art::Handle<std::vector<recob::Hit>> hitHandle; // Handle is a smart pointer
		
	// detprop: Detector Properties
	auto const* detprop = lar::providerFrom<detinfo::DetectorPropertiesService>();
	
	// loop over hit handles (chooses the right event number to run)
	for(std::vector<std::string>::const_iterator hhn = fHitProducerLabel.begin(); hhn != fHitProducerLabel.end(); ++hhn) { // hits are stored un fHitProducer Label for each event
		event.getByLabel(*hhn, hitHandle); // event comes from the input of the function and getByLabel grabs the info

		// if successful at getting hit handle
		if(!(hitHandle.failedToGet())) {
			
			// Loop over hits in said event 
			for(auto hit = hitHandle -> begin(); hit != hitHandle -> end(); ++hit) {
				
				// if hit is in collection plane
				if(fGeometry -> SignalType(hit -> Channel()) == geo::kCollection) {
					
					// Add hit coordinates to a vector
					geo::PlaneID plane_id = (hit -> WireID()).asPlaneID();

					TVectorD vHitPos(2);	// Create a vector of size 2 for storing the hits in the x and z coordinates
					// X [contains the stored hit positions]
					vHitPos[0] = detprop -> ConvertTicksToX((double) hit -> PeakTime(), plane_id) - 102.5;
					
					// Z [contains the stored hit positions with a geometrical factor conversion for wire plane spacing ]
					// -10440 for shifting channel
					vHitPos[1] = ((double) hit -> Channel() - 10440) * pitch; 

					// Make conversion of hits from ADC*Ticks to MeV/cm 					
					double T0 = 0;   // Initial start time
					double dEdx = 0; // In MeV/cm
					double dE = 0; 
					
					// Calls dEdx function and returns the conversion in MeV/cm based on area of hit
					dEdx = fCalorimetryAlg.dEdx_AREA(*hit,pitch, T0)  ; 
					
					// Look for unusually large dEdx values and replace with the previous value to correct
                    if(hit->Integral() > 1000){ 
						
						// Use a modified calibration for dEdx
						dEdx = 0.007484 * hit->Integral() + -.3594; 	
			
					}
					
					// Add to the dQdx and dEdx vectors. 
					vdQdx.push_back(hit->Integral());
					vdEdx.push_back(dEdx);

					// Convert the dE/dx value to dE by multiplying by dx =  0.3 mm;
					dE = dEdx * pitch;
					
					// calculate energy sum
					//dEnergySum += dE; // Sum of all hit energies

					// creates a struct entry which contains the energy and vHitPos (Z,X positions of the hits)
					//addDataEntry(dE, vHitPos);     
					if (vHitPos[1] > 0. ) {addDataEntry(dE, vHitPos); dEnergySum += dE; } // delete any spurious data points (z<0) and add the entries to the vector


					// Add parameters to a vector for a ttree
					if (event.event()==1){
						//Reco_E.push_back(dE);
						//Reco_XPos.push_back(vHitPos[0] - 25); // minus 25 to center on zero in the detector
						//Reco_ZPos.push_back(vHitPos[1]);
					}

				}// End condition if in collection plane

			} // End loop over all hits 

		} // End condition of failed hithandle

	} // End Loop over hit handles

	return dEnergySum;

}

void MolRadReco::beginJob() {
	// Access ART's TFileService, which will handle histograms/trees/etc.
	art::ServiceHandle<art::TFileService> tfs;
	
	//(var, title, nxbins,xlow,xhigh,nybins,ylow,yhigh) TH2D Specifyer

	//dEdx Histogram
	hdEdxValues = tfs->make<TH1D>("dEdxValues","dEdx of Hits; dEdx [Mev/cm]; Events",60,0,25);	

	// Energy Calibration scatter plot
	gECalScat = tfs->makeAndRegister<TGraph>("gECalScat", "EcalScat;dQdx [E/cm]; dEdx [MeV/cm]");
	gECalScat->SetMarkerStyle(kFullDotMedium);
	gECalScat->SetLineWidth(0);

	// Energy Calibration scatter plot
	TruthRecoScat = tfs->makeAndRegister<TGraph>("TruthRecoScat", "Truth Reco Scatter Plot;Truth Energy [MeV]; Reco Energy [MeV]");
	TruthRecoScat->SetMarkerStyle(kFullDotMedium);
	TruthRecoScat->SetMarkerSize(6);
	TruthRecoScat->SetLineWidth(0);

	// *************************** Energy Profile Plots *********************************

	// Energy profile No Algorithm
	hEnergyProfile = tfs->make<TH1D>("energyprofile","Energy Profile of Events; Z [cm]; [MeV/cm]",30,0.,500.);

	// Energy profile PCA RECO
	hEnergyProfilePCA = tfs->make<TH1D>("energyprofilePCA","Energy Profile of Events (PCA Axis); Z [cm]; dEdx [MeV/cm]",100,0.,500.);

	// True Energy profile 
	hTrueEnergyProfile = tfs->make<TH1D>("trueenergyprofile","Energy Profile of Events (Truth); Z [cm]; True dE [MeV]",100,0.,500.);

	// True energy profile in X direction
	hTrueEnergyProfileX = tfs->make<TH1D>("hTrueEnergyProfileX","Energy Profile of Events (Truth) in X Dir; X [cm]; True dE [MeV]",600,-60.,60.);
	
	// True energy profile in R direction
	hTrueEnergyProfileR = tfs->make<TH1D>("hTrueEnergyProfileR","Energy Profile of Events (Truth) in Radial Dir; r [cm]; True dE [MeV]",1000,0.,100.);

	// ********************************************************************************

	// Reco-Truth energy scatter plot
 	hERecoTruthScat= tfs->make<TH2D>("ERecoTruthScat","Scatter Plot of Reco and Truth Energies (muons only); Reco Energy [MeV]; Truth Energy [MeV] ",100,160.,400.,100,160.,400.);
	hERecoTruthScat->SetOption("SCAT");

	// Reco-Truth energy Histogram
	hERecoTruthDiff = tfs->make<TH1D>("ERecoTruthDiff","Difference of Energy Truth minus Reco; Energy Difference [MeV]; Frequency Density",200,-50.,250.);
	
	// Energy Calibration scatter plot
	gCorr_2Dt_3Dt = tfs->makeAndRegister<TGraph>("gCorr_2Dt_3Dt", "2D Truth to 3D Truth Moliere Radius Scatter Plot; 2D Moliere Radius [cm]; 3D Moliere Radius [cm]");
	gCorr_2Dt_3Dt->SetMarkerStyle(kFullDotMedium);
	gCorr_2Dt_3Dt->SetMarkerSize(6);
	gCorr_2Dt_3Dt->SetLineWidth(0);

	// *************************** Event Displays *********************************
	hPosition2D = tfs->make<TH2D>("position2d","2D Position of Hits (Sum of all events); Z [cm]; X [cm]",200,0.,250.,200,-30.,30.); 
	
	hPosition2DSOSA = tfs->make<TH2D>("position2dsosa","2D Position of Hits after SOSA (Sum of all events); Along shower axis [cm]; Perpendicular to shower axis [cm]",200,0.,250.,200,-30.,30.);
	
	hPosition2DPCA = tfs->make<TH2D>("position2dpca","2D Position of Hits after PCA (Sum of all events); Along shower axis [cm]; Perpendicular to shower axis [cm]",250,0.,200.,200,-30.,30.);
	
	hTruePosition2D = tfs->make<TH2D>("trueposition2d","2D Position of Energy Deposits (Sum of all events); Z [cm]; X [cm]",200,0.,250.,200,-30.,30.);
	
	hTruePosition2DSOSA = tfs->make<TH2D>("trueposition2dsosa","2D Position of Energy Deposits after SOSA (Sum of all events);Along shower axis [cm];Perpendicular to shower axis [cm]",200,0.,200.,200,-30.,30.);
	
	hTruePosition2DPCA = tfs->make<TH2D>("trueposition2dpca","2D Position of Energy Deposits after PCA (Sum of all events); Along shower axis [cm]; Perpendicular to shower axis [cm]",200,0.,200.,200,-30.,30.);

	// ********************************************************************************

	// Truth Energy Detected Histogram
	hEnergyDetected = tfs->make<TH1D>("energydetected","Energy Detected in an Event; Energy [MeV]; Frequency Density",50,0.,-5.);
	
	// Histogram used in calculated the Moliere Radius
	hPerpDist = tfs->make<TH1D>("perpdist","Perpendicular Distance (should be empty); X [cm]; Frequency Density",700,0.,35.);

	// *******************************  Moliere Radius Plots ****************************

	hMolRadTruth2D = tfs->make<TH1D>("MoliereTruth2D","Moliere Radius Using Truth Information (Straight Only); Moliere Radius [cm]; Frequency Density",200,0.,-5.);

	hMolRadTruth3D = tfs->make<TH1D>("MoliereTruth3D","Moliere Radius Using Truth Information (Straight Only); Moliere Radius [cm]; Frequency Density",200,0.,-5.);

	hMolRadHitPCA = tfs->make<TH1D>("hitmoliereradiuspca","Moliere Radius Using Hit Information (PCA); Moliere Radius [cm]; Frequency Density",50,0.,-5.);
	
	hMolRadHitSOSA = tfs->make<TH1D>("hitmoliereradiussosa","Moliere Radius Using Hit Information (SOSA); Moliere Radius [cm]; Frequency Density",50,0.,-5.);

	hMolRadTruthPCA2D = tfs->make<TH1D>("truthmoliereradius2Dpca","Moliere Radius Using 2D Truth Information (PCA); Moliere Radius [cm]; Frequency Density",50,0.,-5.);
	
	hMolRadTruthSOSA2D = tfs->make<TH1D>("truthmoliereradius2Dsos","Moliere Radius Using 2D Truth Information (SOSA); Moliere Radius [cm]; Frequency Density",50,0.,-5.);
	
	hMolRadTruthPCA3D = tfs->make<TH1D>("truthmoliereradius3Dpca","Moliere Radius Using 3D Truth Information; Moliere Radius [cm]; Frequency Density",50,0.,-5.);

	// ******************************* Correlation Plots ****************************

	hMolRadCorrelation2Dh2Dt = tfs->make<TH2D>("molradcorrelation2dh2dt","2D Hit - 2D Truth Moliere Radius Correlation (PCA);2D Hit Moliere Radius [cm];2D Truth Moliere Radius [cm]",50,0.,20.,50,0.,20.);
	
	hMolRadCorrelation2Dh3DtPCA = tfs->make<TH2D>("molradcorrelation2dh3dtpca","2D Hit - 3D Truth Moliere Radius Correlation (PCA); 2D Hit Moliere Radius [cm];3D Truth Moliere Radius [cm]",50,0.,20.,50,0.,20.);
	
	hMolRadCorrelation2Dh3DtSOSA = tfs->make<TH2D>("molradcorrelation2dh3dtsosa","2D Hit - 3D Truth Moliere Radius Correlation (SOSA); 2D Hit Moliere Radius (SOSA) [cm]; 3D Truth Moliere Radius (PCA) [cm]",50,0.,20.,50,0.,20.);
	
	hMolRadCorrelation2Dt3Dt = tfs->make<TH2D>("molradcorrelation2dt3dt","2D Truth - 3D Truth Moliere Radius Correlation (PCA); 2D Truth Moliere Radius [cm]; 3D Truth Moliere Radius [cm]",50,0.,20.,50,0.,20.);
	
	hMolRadCorrelationSOSA2Dh2Dt = tfs->make<TH2D>("molradcorrelationSOSA2dh2dt","2D Hit - 2D Truth Moliere Radius Correlation (SOSA); 2D Hit Moliere Radius [cm]; 2D Truth Moliere Radius [cm]",50,0.,20.,50,0.,20.);
	
	hMolRadCorrelation2Dh2DtNorm = tfs->make<TH2D>("molradcorrelation2dh2dtnorm","2D Hit - 2D Truth Moliere Radius Correlation (PCA, Normalised); 2D Hit Moliere Radius [cm]; 2D Truth Moliere Radius [cm]",50,0.,20.,50,0.,20.);
	
	hMolRadCorrelation2Dh3DtPCANorm = tfs->make<TH2D>("molradcorrelation2dh3dtpcanorm","2D Hit - 3D Truth Moliere Radius Correlation (PCA, Normalised); 2D Hit Moliere Radius [cm];3D Truth Moliere Radius [cm]",50,0.,20.,50,0.,20.);

	hMolRadCorrelation2Dh3DtSOSANorm = tfs->make<TH2D>("molradcorrelation2dh3dtsosanorm","2D Hit - 3D Truth Moliere Radius Correlation (SOSA, Normalised); 2D Hit Moliere Radius [cm];3D Truth Moliere Radius [cm]",50,0.,20.,50,0.,20.);
	
	hMolRadCorrelation2Dt3DtNorm = tfs->make<TH2D>("molradcorrelation2dt3dtnorm","2D Truth - 3D Truth Moliere Radius Correlation (PCA, Normalised); 2D Truth Moliere Radius [cm]; 3D Truth Moliere Radius [cm]",50,0.,20.,50,0.,20.);
	
	hMolRadCorrelationSOSA2Dh2DtNorm = tfs->make<TH2D>("molradcorrelationsosa2dh2dtnorm","2D Hit - 2D Truth Moliere Radius Correlation (SOSA, Normalised); 2D Hit Moliere Radius [cm]; 2D Truth Moliere Radius [cm]",50,0.,20.,50,0.,20.);
	
	// Angle between the PCA and SOSA axes
	hPCASOSAAngle = tfs->make<TH1D>("pcasosaangle","Angle between PCA and SOSA vectors; Angle [deg]; Frequency Density",40,0.,-5.);
	
	// Fraction of Truth energy deposited
	hEnergyFraction = tfs->make<TH1D>("energyfraction","Fraction of truth initial energy deposited; Energy Fraction;Frequency Density",50,0.,1.);
	
	// Containment Converted Moliere Radius Histogram
	hMolRadConvertedPCA = tfs->make<TH1D>("moliereradiusconvertedpca","Converted Moliere Radius (MC Hit Information, PCA); Moliere Radius [cm];Frequency Density",50,0.,-5.);
	
	// Create the TTree and add relavent branches
	DataTree = tfs->make<TTree>("EventTree","EventTree"); 

	// Event Information
	DataTree->Branch("run", &run);
	DataTree->Branch("subrun",&subrun);
    DataTree->Branch("event",&evt);
    
    //Truth
    DataTree->Branch("TruthEnergyDeposit", &TruthEnergyDeposits);
    DataTree->Branch("TruthZPos", &TruthZPos);
    DataTree->Branch("TruthXPos", &TruthXPos);

    // ####THESE BRANCHES NEED TO BR UPDATED WITH THE CORRECT VARAIBLE NAMES #########
    // Reconstructed
    //DataTree->Branch("Reco_E", &Reco_E);
    //DataTree->Branch("Reco_ZPos", &Reco_ZPos);
    //DataTree->Branch("Reco_XPos", &Reco_XPos);
    
    // PCA
    //DataTree->Branch("PCA_E", &PCA_E);
    //DataTree->Branch("PCA_ZPos", &PCA_ZPos);
    //DataTree->Branch("PCA_XPos", &PCA_XPos);

	std::cout << "Starting job..." << std::endl;
}


//o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0oo0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0oo0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0oo0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o
void MolRadReco::analyze(art::Event const & event) { // Analyser: runs once per event over all events

	std::cout  << "Event\t" <<event.event() << std::endl; // DIsplay the event number

	// Determine event ID
  	run = event.id().run();
    subrun = event.id().subRun();
    evt = event.id().event();
    
	bool bUseSOSA = true;
	fills+=1; // Add one to fills for rescaling energy profile	
	
	// Energy Sum of Reconstructed Hits
	double dEnergySum = 0.;

	// Run the reconstruction algorithm  
	dEnergySum = GetRecoXYZE(event, dEnergySum ); 

	std::cout << "dEdx sum: " << dEnergySum << std::endl; // Display the total energy that has been reconstructed. 

	double RecoEnergyTotal = dEnergySum ;
	PCA_E_Total+=dEnergySum; // Add to a number to get the total reconstructed energy of all events. 

	RecoEnergyVector.push_back(dEnergySum); // Add the reco energy to a vector

	int N = vEntries.size(); // Total size of vector

    // Fil the scatter plot for dEdx vs Hit integral
    for (unsigned int i=0; i< vdQdx.size(); i++){
		gECalScat -> SetPoint(vdQdx.size(), vdQdx[i], vdEdx[i]); 
	}
	vdQdx.clear(); vdEdx.clear(); // clear the vectors
	
	// Make Histograms
	for (int i = 0; i < N; i++ ) {
		hEnergyProfile->Fill(vEntries[i].position[1], vEntries[i].energy); //Choose 1 event to look at the energy profile
		
		hReco_PerpDist_2D_All->Fill(std::abs(vEntries[i].position[0]), vEntries[i].energy); // Moliere calculation for Reco data

		// Fill 2D histogram (event display like) (Z,X,Energy) Shows a histogram of the x-z plane of all the showers combined
		hPosition2D -> Fill(vEntries[i].position[1], vEntries[i].position[0], vEntries[i].energy); 

		// Fill the dEdx histogram  
		hdEdxValues -> Fill(vEntries[i].energy);
	}

	// Run the PCA Algorithm
	runPCA(); // SWAPS THE BASIS VECTORS AROUND! position[0] is now Z... need to fix this
	
	for (int i = 0; i < N; i++) {
		// Fills a 2D hist for the Z and X coordinates with thier energy after PCA algorithm
		hPosition2DPCA->Fill(vEntries[i].position[vEntries[i].primInd], vEntries[i].position[(vEntries[i].primInd+1)%2], vEntries[i].energy); // (pos.[0],pos.[1],E) 

		//Used for calculating the moliere radius
		hPerpDist->Fill(std::abs(vEntries[i].position[(vEntries[i].primInd+1)%2]), vEntries[i].energy); // (abs(X),E) 

		hReco_PerpDist_2D_PCA_All->Fill(std::abs(vEntries[i].position[1]), vEntries[i].energy); // Moliere calculation for Reco data
		
		// Fills histogram as a function of z and plots against energy
		hEnergyProfilePCA->Fill(vEntries[i].position[vEntries[i].primInd], vEntries[i].energy); 
	}
	 
	// clear PCA entries so can run again for SOSA algorithm
	clearDataEntries(false);
	
	// calculate moliere radius
	double dMolRad2DHitPCA = Containment(dEnergySum, hPerpDist, "T");
	hMolRadHitPCA->Fill(dMolRad2DHitPCA); // Bins the moliere radius frequency density into a histogram
	
	hPerpDist->Reset(); 		          // Reset the variable for use with the SOSA algorithm 
	

	// o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0oo0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o end PCA o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0oo0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o
	// o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0oo0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o begin SOSA o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0oo0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o
	
	// The energy sum of the resonstruction
	dEnergySum = 0.;
	
	// Run the reconstruction algorithm 
	dEnergySum = GetRecoXYZE(event, dEnergySum ); 

	// Run the SOSA algorithm
	runSOSA(30.); // Enter the length of track to align up to was 30.
	
	N = vEntries.size();
	double dMolRad2DHitSOSA = 0.;
	
	if (N != 0) {
		for (int i = 0; i < N; i++) {
			
			// Fills a 2D hist for the Z and X coordinates with thier energy after SOSA algorithm
			hPosition2DSOSA->Fill(vEntries[i].position[vEntries[i].primInd], vEntries[i].position[(vEntries[i].primInd+1)%2], vEntries[i].energy);  
			
			// Used for calculating the moliere radius
			hPerpDist->Fill(std::abs(vEntries[i].position[(vEntries[i].primInd+1)%2]), vEntries[i].energy); 
			
			//hEnergyProfile->Fill(vEntries[i].position[vEntries[i].primInd], vEntries[i].energy); // plot the SOSA energy profile

			hReco_PerpDist_2D_SOSA_All->Fill(std::abs(vEntries[i].position[0]), vEntries[i].energy); // Moliere calculation for Reco data
		}
		
		// clear SOSA entries
		clearDataEntries(false);
		
		// calculate moliere radius
		dMolRad2DHitSOSA = Containment(dEnergySum, hPerpDist, "T");
		hMolRadHitSOSA->Fill(dMolRad2DHitSOSA);
		hPerpDist->Reset();
	} else {
		bUseSOSA = false;
	}
	
	// o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0oo0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o END RECO CALCULATIONS o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0oo0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o
	
	// o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0oo0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o BEGIN TRUTH CALCULATIONS o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0oo0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o
	
	// create vector of simulated channels
	simChannelVec_t simChannelVec; // Decalre simChannleVec as a simChannelVec type
	event.getView(fSimulationProducerLabel, simChannelVec);
	
	// create vector of particles involved in event
	art::Handle< std::vector<simb::MCParticle> > particleHandle;
	event.getByLabel(fSimulationProducerLabel, particleHandle);
	
	double dEnergyInitial = 0.;
	// find primary particle to get initial truth energy
	for(std::vector<simb::MCParticle>::const_iterator particlePtr = particleHandle->begin(); particlePtr != particleHandle->end(); ++particlePtr) {
		const simb::MCParticle& particle = (*particlePtr); // De-reference the particle pointer

		//std::cout <<"PDG\t" <<  particle.PdgCode()  << std::endl; // Print the PDG code of all the particles that were in the event. 

		if (particle.Process() == "primary") {	        // if particle is primary
			dEnergyInitial += particle.Momentum(0).E()*1000.;	// initial energy (adds together over all primary particles)
		}

		// Get the g4 step times for the particles in the event
		//for(unsigned int i=0; i < particle.NumberTrajectoryPoints(); i++) {
		//	std::cout << "Particle postion step time\t" << particle.Position(i).T() << std::endl;
		//}

	}
	
	// o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0oo0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o BEGIN 2D PCA <Truth> o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0oo0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o

	dEnergyDepositedSum = GetTruthXYZE(simChannelVec, false, event.event()); // Get the Truth X, Y Z and Energy for the event
	DataTree->Fill(); // Fill the ttree

	// Calculate the moliere radius for Truth in 2D without alignment, This only makes sense for straight projected showers. 
	for (unsigned int i = 0; i < vEntries.size(); i++) { // fill the perp dist histogram
		
		hPerpDist->Fill(std::abs(vEntries[i].position[(vEntries[i].primInd+1)%2]), vEntries[i].energy); // abs(x), E
		
		hTruth_PerpDist_2D_All->Fill(std::abs(vEntries[i].position[0]), vEntries[i].energy); // Moliere radius calculation for all events
		
		hTrueEnergyProfileX->Fill(vEntries[i].position[0] , vEntries[i].energy); // Fill the truth energy profile histogram for the x direction. uncorrected now

	}

	// Calculate the moliere radius
	double dMolRad2DTruth = Containment(dEnergyDepositedSum, hPerpDist, "T"); 
	std::cout << "MolRad2D Truth\t" << dMolRad2DTruth  << std::endl;
	hMolRadTruth2D->Fill(dMolRad2DTruth);

	hPerpDist->Reset();

	// run PCA
	runPCA();
	
	N = vEntries.size();

	for (int i = 0; i < N; i++) {
		
		hTruePosition2DPCA->Fill(vEntries[i].position[vEntries[i].primInd], vEntries[i].position[(vEntries[i].primInd+1)%2], vEntries[i].energy);
		
		hPerpDist->Fill(std::abs(vEntries[i].position[(vEntries[i].primInd+1)%2]), vEntries[i].energy);
		
		hTrueEnergyProfile->Fill(vEntries[i].position[vEntries[i].primInd], vEntries[i].energy); // Fill the truth energy profile hostogram
		
		hTruth_PerpDist_2D_PCA_All->Fill(std::abs(vEntries[i].position[1]), vEntries[i].energy); // Moliere radius calculation for all events
	}
	
	// clear PCA entries
	clearDataEntries(false);
	
	// calculate moliere radius
	double dMolRad2DTruthPCA = Containment(dEnergyDepositedSum, hPerpDist, "T");
	hMolRadTruthPCA2D->Fill(dMolRad2DTruthPCA);
	hPerpDist->Reset();
	
	// o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0oo0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0oend 2D truth PCA o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0oo0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o
	// o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0oo0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o start 2D truth SOSA o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0oo0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o
	
	dEnergyDepositedSum = 0. ; // Re-Initialize
	
	// Get the Truth X, Y Z and Energy for the event
	dEnergyDepositedSum = GetTruthXYZE(simChannelVec, false, event.event()); 
	
	// run SOSA Algorithm
	runSOSA(30.);
	
	N = vEntries.size();
	double dMolRad2DTruthSOSA = 0.;
	
	if (N != 0) {
		for (int i = 0; i < N; i++) {
			
			hTruePosition2DSOSA->Fill(vEntries[i].position[1], vEntries[i].position[0], vEntries[i].energy);
			
			hPerpDist->Fill(std::abs(vEntries[i].position[0]), vEntries[i].energy); // fills histogram with transverse distance of each energy deposit weighted by the energy
			
			hTruth_PerpDist_2D_SOSA_All->Fill(std::abs(vEntries[i].position[0]), vEntries[i].energy);

			//hTotalXDist->Fill(std::abs(vEntries[i].position[(vEntries[i].primInd+1)%2]), vEntries[i].energy);
			
			//hEnergyProfile->Fill(vEntries[i].position[vEntries[i].primInd], vEntries[i].energy);
			
		}
		
		// Fill Total Truth energy detected
		hEnergyDetected->Fill(dEnergyDepositedSum);
		std::cout<< "TruthEnergyTotal: " << dEnergyDepositedSum <<  std::endl;	

		// Fill the Reco - Truth Hist
		hERecoTruthScat->Fill(RecoEnergyTotal, dEnergyDepositedSum);
		
		// Fill the energy reco-truth difference histogram
		hERecoTruthDiff->Fill(dEnergyDepositedSum - RecoEnergyTotal); 

		// clear PCA entries
		clearDataEntries(false);
		
		// calculate moliere radius
		dMolRad2DTruthSOSA = Containment(dEnergyDepositedSum, hPerpDist, "T");
		hMolRadTruthSOSA2D->Fill(dMolRad2DTruthSOSA);
		hPerpDist->Reset();
	} else {
		bUseSOSA = false;
	}
	
	hPCASOSAAngle->Fill(180.*std::acos(vSOSA[0]*vPCA[0] + vSOSA[1]*vPCA[1])/PI);
	
	// o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0oo0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o END 2D SOSA o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0oo0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o
	// o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0oo0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o BEGIN 3D PCA o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0oo0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o
	
	dEnergyDepositedSum = 0. ; // Re-Initialize
	
	// Get the Truth X, Y Z and Energy for the event
	dEnergyDepositedSum = GetTruthXYZE(simChannelVec, true, event.event()); 
	
	// Add the Truth energy to a vector
	TruthEnergyVector.push_back(dEnergyDepositedSum); 

	// Calculate the moliere radius for Truth in 2D without alignment, This only makes sense for straight projected showers. 
	for (unsigned int i = 0; i < vEntries.size(); i++) { // fill the perp dist histogram
		
		hPerpDist->Fill(std::sqrt(std::pow(vEntries[i].position[0], 2) + std::pow(vEntries[i].position[1], 2)), vEntries[i].energy); // abs(sqrt(x^2 + y^2), E
		
		hTrueEnergyProfileR->Fill(std::sqrt( std::pow(vEntries[i].position[0] ,2) + std::pow(vEntries[i].position[1] ,2) )   , vEntries[i].energy); // Fill the truth energy profile histogram for the radial direction. uncorrected now
		
		hTruth_PerpDist_3D_All->Fill(std::sqrt(std::pow(vEntries[i].position[0] , 2) + std::pow(vEntries[i].position[1], 2)), vEntries[i].energy); // Moliere radius calculation for all events
	}

	double dMolRad3DTruth = Containment(dEnergyDepositedSum, hPerpDist, "T"); // Calculate the moliere radius
	std::cout << "MolRad3D Truth\t" << dMolRad3DTruth << std::endl;
	hMolRadTruth3D->Fill(dMolRad3DTruth);

	hPerpDist->Reset();

	// Run PCA Algorithm
	runPCA();
	
	N = vEntries.size();
	for (int i = 0; i < N; i++) {
		
		hPerpDist->Fill(std::sqrt(std::pow(vEntries[i].position[(vEntries[i].primInd+1)%3], 2) + std::pow(vEntries[i].position[(vEntries[i].primInd+2)%3], 2)), vEntries[i].energy);
		
		//hTrueEnergyProfile->Fill(vEntries[i].position[vEntries[i].primInd], vEntries[i].energy);
		
		hTruth_PerpDist_3D_PCA_All->Fill(std::sqrt(std::pow(vEntries[i].position[(vEntries[i].primInd+1)%3], 2) + std::pow(vEntries[i].position[(vEntries[i].primInd+2)%3], 2)), vEntries[i].energy);// Moliere radius calculation for all events
		
	}
	
	// clear PCA entries
	clearDataEntries(false);
	
	// calculate moliere radius
	double dMolRad3DTruthPCA = Containment(dEnergyDepositedSum, hPerpDist, "T");
	hMolRadTruthPCA3D->Fill(dMolRad3DTruthPCA);
	hPerpDist->Reset(); 
	

	// o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0oo0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0oo0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0oo0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o
	
	// Test Histograms
	//std::cout << hTrueRadialDist3D.Integral(0, iNbins + 1)/dEnergyInitial << std::endl;
	hEnergyFraction->Fill(dEnergyDepositedSum/dEnergyInitial);
	
	// Fill correlation histograms
	hMolRadCorrelation2Dh2Dt->Fill(dMolRad2DHitPCA, dMolRad2DTruthPCA);
	
	hMolRadCorrelation2Dh3DtPCA->Fill(dMolRad2DHitPCA, dMolRad3DTruthPCA);
	
	hMolRadCorrelation2Dh3DtSOSA->Fill(dMolRad2DHitSOSA, dMolRad3DTruthPCA); // there's no 3D sosa in this code :/
	
	hMolRadCorrelation2Dt3Dt->Fill(dMolRad2DTruthPCA, dMolRad3DTruthPCA);
	
	gCorr_2Dt_3Dt-> SetPoint(event.event(),dMolRad2DTruth,dMolRad3DTruth);
	
	if (bUseSOSA) hMolRadCorrelationSOSA2Dh2Dt->Fill(dMolRad2DHitSOSA, dMolRad2DTruthSOSA);
	
	// Fill converted moliere radius histogram
	// define final correlation fit here (R_M = P1*r_M + P0)
	double P0 = -5.841; // If you want uncontained aprox use P0 = 0.119 and P1 = 1.753
	double P1 = 4.325;
	hMolRadConvertedPCA->Fill(dMolRad2DHitPCA*P1 + P0);

}
// o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0oo0o0o0o0o0o0o0o0o END JOB 0o0o0o0o0o0o0o0oo0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0oo0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o0o
void MolRadReco::endJob()
{
	// Normalize Histograms
	std::cout << "Beginning END JOB " << std::endl;

	// Loop over all y bins
	for (int j = 1; j <= hMolRadCorrelation2Dh2Dt->GetNbinsY(); j++) { 
		double iYCount = 0; // Total value in each row, reset every loop
		
		// Loop over all x bins in a bin y
		for (int i = 1; i <= hMolRadCorrelation2Dh2Dt->GetNbinsX(); i++) { 
			iYCount += (double) hMolRadCorrelation2Dh2Dt->GetBinContent(i, j);
		}
		
		// Divide each element in row by the total value in the row. 
		for (int i = 1; i <= hMolRadCorrelation2Dh2Dt->GetNbinsX(); i++) {
			if (iYCount != 0.) {
				hMolRadCorrelation2Dh2DtNorm->SetBinContent(i, j, hMolRadCorrelation2Dh2Dt->GetBinContent(i, j) / iYCount); 
			}
		}
	}

	for (int j = 1; j <= hMolRadCorrelation2Dh3DtPCA->GetNbinsY(); j++) {
		double iYCount = 0;
		for (int i = 1; i <= hMolRadCorrelation2Dh3DtPCA->GetNbinsX(); i++) {
			iYCount += (double) hMolRadCorrelation2Dh3DtPCA->GetBinContent(i, j);
		}
		for (int i = 1; i <= hMolRadCorrelation2Dh3DtPCA->GetNbinsX(); i++) {
			if (iYCount != 0.) {
				hMolRadCorrelation2Dh3DtPCANorm->SetBinContent(i, j, hMolRadCorrelation2Dh3DtPCA->GetBinContent(i, j) / iYCount);
			}
		}
	}

	for (int j = 1; j <= hMolRadCorrelation2Dh3DtSOSA->GetNbinsY(); j++) {
		double iYCount = 0;
		for (int i = 1; i <= hMolRadCorrelation2Dh3DtSOSA->GetNbinsX(); i++) {
			iYCount += (double) hMolRadCorrelation2Dh3DtSOSA->GetBinContent(i, j);
		}
		for (int i = 1; i <= hMolRadCorrelation2Dh3DtSOSA->GetNbinsX(); i++) {
			if (iYCount != 0.) {
				hMolRadCorrelation2Dh3DtSOSANorm->SetBinContent(i, j, hMolRadCorrelation2Dh3DtSOSA->GetBinContent(i, j) / iYCount);
			}
		}
	}

	for (int j = 1; j <= hMolRadCorrelation2Dt3Dt->GetNbinsY(); j++) {
		double iYCount = 0;
		for (int i = 1; i <= hMolRadCorrelation2Dt3Dt->GetNbinsX(); i++) {
			iYCount += (double) hMolRadCorrelation2Dt3Dt->GetBinContent(i, j);
		}
		for (int i = 1; i <= hMolRadCorrelation2Dt3Dt->GetNbinsX(); i++) {
			if (iYCount != 0.) {
				hMolRadCorrelation2Dt3DtNorm->SetBinContent(i, j, hMolRadCorrelation2Dt3Dt->GetBinContent(i, j) / iYCount);
			}
		}
	}

	for (int j = 1; j <= hMolRadCorrelationSOSA2Dh2Dt->GetNbinsY(); j++) {
		double iYCount = 0;
		for (int i = 1; i <= hMolRadCorrelationSOSA2Dh2Dt->GetNbinsX(); i++) {
			iYCount += (double) hMolRadCorrelationSOSA2Dh2Dt->GetBinContent(i, j);
		}
		for (int i = 1; i <= hMolRadCorrelationSOSA2Dh2Dt->GetNbinsX(); i++) {
			if (iYCount != 0.) {
				hMolRadCorrelationSOSA2Dh2DtNorm->SetBinContent(i, j, hMolRadCorrelationSOSA2Dh2Dt->GetBinContent(i, j) / iYCount);
			}
		}
	}
	
	

	// Fit the ECalScat graph
	gECalScat->Fit("pol1", "","", 0, 1000);
	ECalScatFit = gECalScat->GetFunction("pol1");
	double p0 = ECalScatFit->GetParameter(0);
	double p1 = ECalScatFit->GetParameter(1);
	std::cout <<"ENERGY FIT PARAMETERS  " << "P0: " << p0 << "    P1: " << p1 << std::endl;

	// Fit the Reco-Truth Difference plot
	double meanECalScatFit; // For shifting the data
	hERecoTruthDiff -> Fit("gaus", "","");
	ECalScatFit = hERecoTruthDiff->GetFunction("gaus");
	//double meanECalScatFit = ECalScatFit->GetParameter("Mean"); // Turn on if want to scale 
	
	// Rescale the dEdx Histogram by the area
	hdEdxValues->Scale(1./hdEdxValues->Integral());
	hdEdxValues->Sumw2(kFALSE);

	// Rescale the histogram by the number of fills (entries)
	std::cout << "Integral = "<< hEnergyProfile -> GetEntries() << std::endl; // Output the number of entries 
	
	// Scale the PCA Energy Profile
	//hEnergyProfilePCA->Scale(1./fills);	

	std::cout << "Integral reco "<< hEnergyProfile -> Integral("width") << std::endl; // Output the number of entries 


	// True energy profile normalised
	double scale = hTrueEnergyProfile->GetBinContent(hTrueEnergyProfile->GetMaximumBin()); // Scale by the max bin value
	hTrueEnergyProfile->Scale (1./scale);
	
	Truth_E_Total+=hTrueEnergyProfile -> Integral();
	//hTrueEnergyProfile->Scale (1./fills);
	std::cout << "IntegralTrue= "<< hTrueEnergyProfile -> Integral() << std::endl; // Output the number of entries 
	
	// Fit the true energy longitudinal profle
	TrueEnergyProfileFit -> SetParLimits(0,  1,  6);    // ALPHA
    TrueEnergyProfileFit -> SetParLimits(1,  1,  1e4);  // AMP
    TrueEnergyProfileFit -> SetParLimits(2,  0,  30);   // MU
    TrueEnergyProfileFit -> SetParLimits(3,  1,  30);   // THETA
	hTrueEnergyProfile->Fit("TrueEnergyProfileFit","R"); 
	TrueEnergyProfileFit = hTrueEnergyProfile->GetFunction("TrueEnergyProfileFit");

	
	

	// Normalise reco Energy profile
	// scale = hEnergyProfile->GetBinContent(hEnergyProfile->GetMaximumBin()); // Scale by the max bin value
	// hEnergyProfile -> Scale(1./scale);

	// scale = hEnergyProfilePCA->GetBinContent(hEnergyProfilePCA->GetMaximumBin());
	// hEnergyProfilePCA -> Scale(1./scale);

	// Make a plot of truth energy vs reco-energy+fit
	meanECalScatFit = 0; // Delete this if you want a correction
	for (size_t k = 0; k < RecoEnergyVector.size(); k++){
		TruthRecoScat->SetPoint(k, TruthEnergyVector[k],RecoEnergyVector[k] + meanECalScatFit ); 
	}

	TruthRecoScat->Fit("pol1","");
	TruthRecoScatFit = TruthRecoScat->GetFunction("pol1");

	// **************************Calculate the containment for multiple showers.  ***********************
	double E_total = Truth_E_Total; // Define for truth or reco moliere radius Truth_E_Total for Truth
	std::cout<<"Total ENERGY: " << E_total << std::endl;
    
	// Calculate the Longitudinal containment of a shower
	double L_Containment = Containment(hTrueEnergyProfile->Integral(), hTrueEnergyProfile, "L"); // Longitudinal Containment

	// Calculate the Moliere Radius over all showers 
	double hReco_PerpDist_2D_Rm = 	    Containment(	hReco_PerpDist_2D_All->Integral()      ,hReco_PerpDist_2D_All      ,"T");
	double hReco_PerpDist_2D_PCA_Rm =   Containment(	hReco_PerpDist_2D_PCA_All->Integral()  ,hReco_PerpDist_2D_PCA_All  ,"T");
	double hReco_PerpDist_2D_SOSA_Rm =  Containment(	hReco_PerpDist_2D_SOSA_All->Integral() ,hReco_PerpDist_2D_SOSA_All ,"T");
	double hTruth_PerpDist_2D_Rm = 	    Containment(	hTruth_PerpDist_2D_All->Integral()     ,hTruth_PerpDist_2D_All     ,"T");
	double hTruth_PerpDist_2D_PCA_Rm =  Containment(	hTruth_PerpDist_2D_PCA_All->Integral() ,hTruth_PerpDist_2D_PCA_All ,"T");
	double hTruth_PerpDist_2D_SOSA_Rm = Containment(	hTruth_PerpDist_2D_SOSA_All->Integral(),hTruth_PerpDist_2D_SOSA_All,"T");
	double hTruth_PerpDist_3D_Rm = 		Containment(	hTruth_PerpDist_3D_All->Integral()     ,hTruth_PerpDist_3D_All     ,"T");
	double hTruth_PerpDist_3D_PCA_Rm =  Containment(	hTruth_PerpDist_3D_PCA_All->Integral() ,hTruth_PerpDist_3D_PCA_All ,"T");

	// Calculate 2 * the Moliere Radius over all showers 
	double hReco_PerpDist_2D_2Rm = 	     Containment(	hReco_PerpDist_2D_All->Integral()      ,hReco_PerpDist_2D_All      ,"T2");
	double hReco_PerpDist_2D_PCA_2Rm =   Containment(	hReco_PerpDist_2D_PCA_All->Integral()  ,hReco_PerpDist_2D_PCA_All  ,"T2");
	double hReco_PerpDist_2D_SOSA_2Rm =  Containment(	hReco_PerpDist_2D_SOSA_All->Integral() ,hReco_PerpDist_2D_SOSA_All ,"T2");
	double hTruth_PerpDist_2D_2Rm = 	 Containment(	hTruth_PerpDist_2D_All->Integral()     ,hTruth_PerpDist_2D_All     ,"T2");
	double hTruth_PerpDist_2D_PCA_2Rm =  Containment(	hTruth_PerpDist_2D_PCA_All->Integral() ,hTruth_PerpDist_2D_PCA_All ,"T2");
	double hTruth_PerpDist_2D_SOSA_2Rm = Containment(	hTruth_PerpDist_2D_SOSA_All->Integral(),hTruth_PerpDist_2D_SOSA_All,"T2");
	double hTruth_PerpDist_3D_2Rm = 	 Containment(	hTruth_PerpDist_3D_All->Integral()     ,hTruth_PerpDist_3D_All     ,"T2");
	double hTruth_PerpDist_3D_PCA_2Rm =  Containment(	hTruth_PerpDist_3D_PCA_All->Integral() ,hTruth_PerpDist_3D_PCA_All ,"T2");


	std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n" << std::endl;
	std::cout << "True Longitudinal Profile 95% Containment:\t" << L_Containment  << std::endl;
	std::cout << "True Longitudinal Profile Max Bin:\t" << hTrueEnergyProfile -> GetBinCenter(hTrueEnergyProfile -> GetMaximumBin())  << std::endl;
	std::cout << "True Longitudinal Profile Max Bin Fit:\t" << TrueEnergyProfileFit->GetMaximumX() << std::endl;
	std::cout << std::endl;
	std::cout << "Moliere Radius Reco 2D:\t\t" 	   << hReco_PerpDist_2D_Rm        << "\t 2 * Moliere Radius Reco 2D:\t\t"        << hReco_PerpDist_2D_2Rm    << std::endl;
	std::cout << "Moliere Radius Reco 2D PCA:\t"   << hReco_PerpDist_2D_PCA_Rm    << "\t 2 * Moliere Radius Reco 2D PCA:\t"   << hReco_PerpDist_2D_PCA_2Rm   << std::endl;
	std::cout << "Moliere Radius Reco 2D SOSA:\t"  << hReco_PerpDist_2D_SOSA_Rm   << "\t 2 * Moliere Radius Reco 2D SOSA:\t"  << hReco_PerpDist_2D_SOSA_2Rm  << std::endl;
	std::cout << std::endl;
	std::cout << "Moliere Radius Truth 2D:\t"	   << hTruth_PerpDist_2D_Rm       << "\t 2 * Moliere Radius Truth 2D:\t\t"	  << hTruth_PerpDist_2D_2Rm      << std::endl;
	std::cout << "Moliere Radius Truth 2D PCA:\t"  << hTruth_PerpDist_2D_PCA_Rm   << "\t 2 * Moliere Radius Truth 2D PCA:\t"  << hTruth_PerpDist_2D_PCA_2Rm  << std::endl;
	std::cout << "Moliere Radius Truth 2D SOSA:\t" << hTruth_PerpDist_2D_SOSA_Rm  << "\t 2 * Moliere Radius Truth 2D SOSA:\t" << hTruth_PerpDist_2D_SOSA_2Rm << std::endl;
	std::cout << std::endl;
	std::cout << "Moliere Radius Truth 3D:\t" 	   << hTruth_PerpDist_3D_Rm       << "\t 2 * Moliere Radius Truth 3D:\t\t" 	  << hTruth_PerpDist_3D_2Rm      << std::endl;
	std::cout << "Moliere Radius Truth 3D PCA:\t"  << hTruth_PerpDist_3D_PCA_Rm   << "\t 2 * Moliere Radius Truth 3D PCA:\t"  << hTruth_PerpDist_3D_PCA_2Rm  << std::endl;
	std::cout << "\n\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" << std::endl;



	// Fit the Radial Energy Profile
	//hTrueEnergyProfileR->Scale(1./hTrueEnergyProfileR->GetBinContent(hTrueEnergyProfileR->GetMaximumBin())); // Scale by the max bin number
	hTrueEnergyProfileR->Scale(1./fills); // Scale by the numbre of fills

	hTrueEnergyProfileR->Fit("TProfFit_Radial","R");
	TProfFit = hTrueEnergyProfileR->GetFunction("TProfFit_Radial");

	// Define and fit the transverse energy profile.
	// Set fit parameter limits
    //float par0LowLimit = 3000.0,   par0UpLimit = 20000.0; // Limit for area0
    //float par1LowLimit =    -0.,   par1UpLimit =      0.; // Limit for mean1
    //float par2LowLimit =    0.8,   par2UpLimit =      1.1; // Limit for sigma1

    //float par3LowLimit =   1000.,   par3UpLimit =  3000.0; // Limit for area2
    //float par4LowLimit =    -0.,   par4UpLimit =      0.; // Limit for mean2
    //float par5LowLimit =    0.5,   par5UpLimit =      7.; // Limit for sigma2
	//hTrueEnergyProfileX->Scale(1./hTrueEnergyProfileX->GetBinContent(hTrueEnergyProfileX->GetMaximumBin())); // Scale by the max bin number
	

	// Lorenzian Parameters
    float par0LowLimit =  1e-4,   par0UpLimit =     0.1; // Limit for Width
    float par1LowLimit =  1e-7,   par1UpLimit =    0.01; // Limit for Scale
    float par2LowLimit =  1e-4,   par2UpLimit =    1e-2; // Limit for Amp
    float par3LowLimit =  -0.5,   par3UpLimit =     0.5; // Limit for Mean

    // Gaussian Parameters
    float par4LowLimit =    0.1,   par4UpLimit =      1.1; // Limit for amp2
    float par5LowLimit =     0.,   par5UpLimit =       0.; // Limit for mean2
    float par6LowLimit =   0.01,   par6UpLimit =      0.3; // Limit for Sigma2


	//TProfFit-> SetParNames("amp1", "mean1", "sigma1","amp2", "mean2", "sigma2");
	TProfFit-> SetParNames("Width", "Scale", "Amp", "Mean","Amp_Gaus", "Mean_Gaus", "Sigma_Gaus");
	
	// Set the Parameter limits
	TProfFit -> SetParLimits(0,  par0LowLimit,  par0UpLimit);
    TProfFit -> SetParLimits(1,  par1LowLimit,  par1UpLimit);
    TProfFit -> SetParLimits(2,  par2LowLimit,  par2UpLimit);
    TProfFit -> SetParLimits(3,  par3LowLimit,  par3UpLimit);
    TProfFit -> SetParLimits(4,  par4LowLimit,  par4UpLimit);
    TProfFit -> SetParLimits(5,  par5LowLimit,  par5UpLimit);
    TProfFit -> SetParLimits(6,  par6LowLimit,  par6UpLimit);
	
	hTrueEnergyProfileX->Fit("TProfFit","R");
	TProfFit = hTrueEnergyProfileX->GetFunction("TProfFit");

	// Calculate moliere radius based on the transverse profile x or radial.
	// NOTE CHANGE xmin if changing h
	TH1D* h = hTrueEnergyProfileR; //choose histogram
	//TH1D* h = hTrueEnergyProfileX; //choose histogram

	TAxis *axis = h->GetXaxis();
	int bmin = 0 ;
	int bmax = 0 ;
	double integral_range = 0;
	double integral_total = h ->Integral();
	double xmin = 0;
	double xmax = 0;

	double integralimit = 40.0;


	// NOTE CHANGE xmin if changing h
	for (double k = 0; k < integralimit; k+=0.1){
		//xmin = -1 * k; // 2D
		xmin =0;  // 3D
		xmax = k ;

		bmin = axis->FindBin(xmin); 
		bmax = axis->FindBin(xmax); 


		integral_range = h->Integral(bmin,bmax);
		integral_range -= h->GetBinContent(bmin) * ( xmin - axis->GetBinLowEdge(bmin) ) / axis->GetBinWidth(bmin);
		integral_range -= h->GetBinContent(bmax) * ( axis->GetBinUpEdge(bmax)- xmax) / axis->GetBinWidth(bmax);

		if (integral_range >= 0.9*integral_total) {
			std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n" << std::endl;
			std::cout << "Integral range = " << integral_range << "\t Total Integral = " << integral_total << "\tMoliereRadius = " << k << std::endl;
			std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n" << std::endl;
			break; 
		}

		if (k == integralimit) std::cout <<  "REACHED LIMIT OF RANGE" << std::endl;

	}

	clearDataEntries(true); // clear the tree variables

}

DEFINE_ART_MODULE(MolRadReco)