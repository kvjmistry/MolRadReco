////////////////////////////////////////////////////////////////////////
// Class:       MolRadReco
// Plugin Type: analyzer (art v2_07_03)
// File:        MolRadReco_module.cc
// LArIAT
//
// Generated at Fri Aug 11 12:10:37 2017 by Dylan White using cetskelgen
// from cetlib version v3_00_01.

// Modified by Krishan Mistry 11-10-2017 e: krishan.mistry-5@postgrad.manchester.ac.uk

////////////////////////////////////////////////////////////////////////

// Default art includes
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Optional/TFileService.h"

// LARSOFT includes
#include "lardataobj/Simulation/SimChannel.h" //
#include "lardataobj/Simulation/SimPhotons.h" //
#include "lardataobj/Simulation/AuxDetSimChannel.h" //
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h" //
#include "lardata/DetectorInfo/DetectorPropertiesStandard.h" //
#include "larsim/Simulation/LArG4Parameters.h" //
#include "larcore/Geometry/Geometry.h" //
#include "larreco/Calorimetry/CalorimetryAlg.h" //
#include "lardataobj/RecoBase/Hit.h" //
#include "larreco/Calorimetry/CalorimetryAlg.h" 			// For dEdx conversion
#include "larreco/RecoAlg/ClusterRecoUtil/ClusterParamsAlg.h"				// for cluster params alg function 
#include "larevt/CalibrationDBI/Interface/ElectronLifetimeService.h"    // For dEdx conversion
#include "larevt/CalibrationDBI/Interface/ElectronLifetimeProvider.h"   // For dEdx conversion

#include "nutools/ParticleNavigation/ParticleList.h" //
#include "nutools/ParticleNavigation/EmEveIdCalculator.h" //
#include "larcoreobj/SimpleTypesAndConstants/geo_types.h" //

// ROOT includes
#include "TH1.h" 
#include "TH2.h" 
#include "TH3.h" 
#include "TTree.h" 
#include "TDatabasePDG.h" 
#include "TParticlePDG.h" 
#include "TCanvas.h" 
#include "TVectorT.h" 
#include "TMatrixT.h" 
#include "TMatrixDUtils.h" 
#include "TGraph.h" 
#include "TF1.h" 
#include "TMath.h"

// C++ Includes
#include <cmath>
#include <map>
#include <iostream>
#include <algorithm>

#define PI 3.14159265

TH1D* hPerpDist;		// For calculating moliere radius
TH1D* hPerpDist_All; // perpendicular distance for moliere radius of all events

// these are for the testing PCA-SOSA angle thing. That can be removed
TVectorD vSOSA(2);
TVectorD vPCA(2);
int fills = 0;
typedef std::vector<const sim::SimChannel*> simChannelVec_t; //Alias for a type name
int HistFill = 999; // Bool to decide if to fill a histogram or not (avoids overfilling truth position 2D)


//* This structure stores the energy,position and index of events
class entry {
public:
	TVectorD position;
	double energy;
	int primInd;	// used only for PCA (NOTE this isn't actually needed in the entry struct, it's the same for all entries in an event. This can be changed later, but probably won't speed it up a huge amount.)
	bool operator <(const entry& rhs) {	// compare final element for SOSA sorting (should only be n=2 currently)
		return position[position.GetNoElements()-1] < rhs.position[rhs.position.GetNoElements()-1];
	}
};

class MolRadReco;

class MolRadReco : public art::EDAnalyzer {
public:
  explicit MolRadReco(fhicl::ParameterSet const & p);
  // The compiler-generated destructor is fine for non-base
  // classes without bare pointers or other resource use.

  // Plugins should not be copied or assigned. Automatically generated by program
  MolRadReco(MolRadReco const &) = delete;
  MolRadReco(MolRadReco &&) = delete;
  MolRadReco & operator = (MolRadReco const &) = delete;
  MolRadReco & operator = (MolRadReco &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Selected optional functions. Automatically generated
  void beginJob() override;
  void beginRun(art::Run const & r) override;
  void beginSubRun(art::SubRun const & sr) override;
  void endJob() override;
  void endRun(art::Run const & r) override;
  void endSubRun(art::SubRun const & sr) override;
 
  
  // custom functions
  void addDataEntry(double energy, TVectorD position); // creates a struct of type entry which contains energy, position and index. 
  void clearDataEntries(bool cleartree);
  void runPCA();		// principal component analysis
  void runSOSA(double cm);	// start of shower alignment
  double moliereRadius(double energySum); // calulates the moiere radius
  double GetTruthXYZE(simChannelVec_t simChannelVec, bool use3D, int event);

private:

	// Declare member data here.
	// parameters from the .fcl file.
	std::string fSimulationProducerLabel;		// The name of the producer that tracked simulated particles through the detector
	std::vector<std::string> fHitProducerLabel;     // The name of the producer that created hits
	
	TGraph* TruthRecoScat;             		// Scatterplot of truth vs reco+correction energy

	TH2D* hPosition2D;			        	// Shows a histogram of the x-z plane of all the showers combined
	TH2D* hPosition2DSOSA;			        // 2D position after Start Of Shower Alignment algorithm
	TH2D* hPosition2DPCA;			        // 2D position after the Principal Component Analysis algorithm
	
	TH3D* hTruePosition3D;	                // 3D position
	TH3D* hTruePosition3DPCA;		        // 3D position after Principal Component Analysis
	TH2D* hTruePosition2D;				
	TH2D* hTruePosition2DSOSA;
	TH2D* hTruePosition2DPCA;
	TH1D* hEnergyDetected;				 	// Total amount of energy detected in an event
	
	// Energy Profiles
	TH1D* hEnergyProfilePCA;				 // Energy as a function of Z (energy profile) PCA Axis
	TH1D* hEnergyProfile;					 // Energy profile, no axis
	TH1D* hTrueEnergyProfile;				 // ^^^ but for truth information
	TH1D* hTrueEnergyProfileX; 				 // True energy profile in the x direction
	TH1D* hTrueEnergyProfileR; 				 // True energy profile in the radial direction
		
	//TF1* TProfFit;  						// Fitting function to the transverse energy profile. 
	//TF1* TProfFit = new TF1("TProfFit","gaus(0)+gaus(3)",-20., 20.); // Fit function for energy prifile
	TF1* TProfFit = new TF1("TProfFit","[2]*[0]/([1]*(x-[3])*(x-[3]) + [0]*[0]) + gaus(4) ",10., 10.); // Lorenzian
	TF1* TProfFit_Radial = new TF1("TProfFit_Radial"," landau ",0., 20.); // Fit function for energy prifile

	// Moliere Radius
	TH1D* hMolRadHitPCA;			  	 
	TH1D* hMolRadHitSOSA;
	TH1D* hMolRadTruthPCA2D;
	TH1D* hMolRadTruthSOSA2D;
	TH1D* hMolRadTruthPCA3D;

	TH1D* hMolRadTruth2D; 
	TH1D* hMolRadTruth3D; 
	
	// Moliere Radius Correlation plots
	TH2D* hMolRadCorrelation2Dh2Dt;			
	TH2D* hMolRadCorrelation2Dh3DtPCA;
	TH2D* hMolRadCorrelation2Dh3DtSOSA;
	TH2D* hMolRadCorrelation2Dt3Dt;
	TGraph* gCorr_2Dt_3Dt;				// TGraph for 2D truth vs 3D truth for conversion factor
	TH2D* hMolRadCorrelationSOSA2Dh2Dt;

	TH2D* hMolRadCorTruth;

	TH1D* hCorr_2DReco_2DTruth_PCA; 
	TH1D* hCorr_2DReco_2DTruth_SOSA; 

	
	// Normalised Correlation Plots
	TH2D* hMolRadCorrelation2Dh2DtNorm;		 
	TH2D* hMolRadCorrelation2Dh3DtPCANorm;
	TH2D* hMolRadCorrelation2Dh3DtSOSANorm;
	TH2D* hMolRadCorrelation2Dt3DtNorm;
	TH2D* hMolRadCorrelationSOSA2Dh2DtNorm;
	
	TH1D* hPCASOSAAngle;				// for debugging 3D PCA
	TH1D* hEnergyFraction;				// for seeing if full Mol Rad calculation is feasible
	TH1D* hMolRadConvertedPCA;			// test output histogram for converted Mol. Rad. values
	
	TH1D* hdEdxValues;					// Histogram of the dEdx values for a muon for energy calibration check

	TGraph* gECalScat; 				    // Scatter plot of dEdx vs dQdx for energy calibration
	TF1*    ECalScatFit; 				// Fit function for the ECal Scat graph

	TH2D* hERecoTruthScat; 				// Scatter plot of the reco to truth energy (muons only)
	TF1* TruthRecoScatFit;              // Fit function for truth reco scatter plot

	TH1D* hERecoTruthDiff; 				// Histogram of the difference between reco and truth energy
	TF1* ERecoTruthDiffFit;             // Fit for reco-truth difference.

	calo::CalorimetryAlg  fCalorimetryAlg;          // Calorimetry Alg to convert to ADC*Ticks to dEdx

	//cluster::ClusterParamsAlg  fClusterParamsAlg;   // Cluster params alg implementaion. 
	
	// other misc. objects
	art::ServiceHandle<geo::Geometry> fGeometry;	// pointer to Geometry service
	double pitch = 0.4 / std::cos(PI / 6.);	        // 4 mm wire spacing 60 degree orientation
	double dEnergySumTotal;		                // total energy over all events
	
	// To store the hit position and energy
	std::vector<entry> vEntries;

	// typedefs
	typedef TMatrixT<double> TMatrixD;
	
	double dEnergyDepositedSum; 

	std::vector<double> RecoEnergyVector;
	std::vector<double> TruthEnergyVector;

	//TTree Declaration and Variables to add
	TTree* DataTree; 
	// Declare analysis variables
    int run, subrun, evt;
    std::vector<double> TruthEnergyDeposits;
    std::vector<double> TruthZPos;
    std::vector<double> TruthXPos;

    // Vectors containing Reconstructed parameters
    //std::vector<double> Reco_E;
    //std::vector<double> Reco_ZPos;
    //std::vector<double> Reco_XPos;

    // Vectors containing PCA parameters
    //std::vector<double> PCA_XPos; 
    //std::vector<double> PCA_ZPos;
    double PCA_E_Total;
    double Truth_E_Total; 




};

void MolRadReco::addDataEntry(double energy, TVectorD position) {
	// check entry validity
	bool addEntry = true;
	if (vEntries.size() > 0) { //check the vector is not empty (vEntries is a vector of entries)
		if (!(vEntries[0].position.GetNoElements() == position.GetNoElements())) { //checks that the position vector dimentions are compatable
			addEntry = false; // not equal so throw error
			std::cout << "Could not add PCA entry - incorrect position vector dimensions" << std::endl;
		}
	}
	if (energy < 0.) { // check for energies less than zero
		addEntry = false;
		std::cout << "Could not add PCA entry - invalid energy value (< 0)" << std::endl;
	}

	// A valid entry has been found so add to vEntries
	if (addEntry) {
		entry e;  
		e.position.ResizeTo(position); // resizes the position vector to the input position  vector size
		e.position = position; // add the position
		e.energy = energy;     // add the energy
		e.primInd = -25;	//** placeholder - can use for checks later. 
		vEntries.push_back(e);

	}

	return;
}

void MolRadReco::clearDataEntries(bool cleartree) {
	vEntries.clear();
	TruthEnergyDeposits.clear();
	TruthZPos.clear();
	TruthXPos.clear();

	//  Clear all the Tree Variables
	if (cleartree ==true){
		
		//Reco_E.clear();
		//Reco_XPos.clear();
		//Reco_ZPos.clear();
		//PCA_E.clear();
		//PCA_XPos.clear();
		//PCA_ZPos.clear();

	}

	return;
}

void MolRadReco::runPCA() {
	// initial checks
	
	// define stuff
	int dim = vEntries[0].position.GetNoElements(); // Number of dimentions - 2 or 3
	int N = vEntries.size(); 
	
	int iPrimaryIndex;
	// vectors
	TVectorD vMean(dim);
	TVectorD vCoords(dim);
	TVectorD vEigval(dim);
	TMatrixD mEigvec(dim, dim); // The largest eigenvector points in the direction of the PCA axis (2x2 matrix)
	TMatrixD mCovariance(dim, dim);
	mCovariance = 0.;
	// misc
	double dEnergySqSum = 0;
	
	// loop 1 - calculate means, energy (sq) sums
	for(int i = 0; i < N; i++) {
		// calculate mean positions
		for (int x = 0; x < dim; x++) {
			vMean[x] += vEntries[i].position[x]; // Sums the positions for x and z (and y) to vector vMean
		}
		// calculate energy (sq) sums
		dEnergySqSum += std::pow(vEntries[i].energy, 2);
	}
	vMean *= 1./((double) N); 


	// loop 2 - fill covm
	for(int i = 0; i < N; i++) {
		// fill Covariance matrix
		for (int b = 0; b < vMean.GetNoElements(); b++) { // vMean.GetNoElements() = 2 or 3
			for (int a = 0; a < vMean.GetNoElements(); a++) {
				mCovariance(a,b) += (vEntries[i].position[a] - vMean[a])*(vEntries[i].position[b] - vMean[b])*std::pow(vEntries[i].energy, 2);
			}
		}
	}
	
	// finish Covariance matrix calculation
	mCovariance *= 1./((hPosition2D->GetEntries() - 1.)*dEnergySqSum); // Calculates the equation of sigmaxy in dylans report
	
	// Get eigenvecs/vals, and transpose eigenvecs matrix
	mEigvec = mCovariance.EigenVectors(vEigval); // Also fills supplied vector with Eigenvalues
	mEigvec.Transpose(mEigvec);					 // Transpose
	
	// Get primary eigenvector - the one with the largest eigenvalue - indexes the PCA axis vector
	iPrimaryIndex = 0;
	for (int i = 1; i < dim; i++) {
		if (std::abs(vEigval[i]) > std::abs(vEigval[iPrimaryIndex])) {
			iPrimaryIndex = i;
		}
	}

	// Look at the primary index
	//std::cout << "The PCA Primary Index is: " << iPrimaryIndex << std::endl;
	
	// If the primary eigenvector is negative (Z < 0) then flip its direction
	if (mEigvec(iPrimaryIndex, dim - 1) < 0.) {
		mEigvec *= -1.;
		//std::cout << "Negative eigenvector -> Flipping the Eigenvector sign..." << std::endl;
	}

	// loop 3 - transform coordinates, save primary index coords, find lowest Z
	int iLowestZ = 0;
	for(int i = 0; i < N; i++) {
		vEntries[i].position -= vMean; 			// Subtract the mean
		vEntries[i].position *= mEigvec; 		// Transform to PCA eigenvector basis - Should now align the shower horizontally
		vEntries[i].primInd = iPrimaryIndex; 	// Sets the PCA axis vector index for all coordinates

		// Finds the lowest Z value (to shift to the starting point of the shower Z=0)
		if (vEntries[i].position[iPrimaryIndex] < vEntries[iLowestZ].position[iPrimaryIndex]) {
			iLowestZ = i;
		}
	}

	
	// loop 4 - shift coordinates to start at lowest X;
	double dZShift = vEntries[iLowestZ].position[iPrimaryIndex];
	for(int i = 0; i < N; i++) {
		vEntries[i].position[iPrimaryIndex] -= dZShift;
	}
	
	// fill vector check
	if (dim == 2) {
		vPCA[0] = mEigvec(iPrimaryIndex, 1); // X
		vPCA[1] = mEigvec(iPrimaryIndex, 0); // Z
	}
	
	// Output the PCA axis vector and the angle to the beam direction (Z)
	//std::cout << "("<<  mEigvec(iPrimaryIndex, 1) << ", "<< mEigvec(iPrimaryIndex, 0)<< ")"<< std::endl;
	//std::cout << "Angle: " << (180 / PI)* std::atan(vPCA[1]/vPCA[0]) << std::endl;	
	return;
}

void MolRadReco::runSOSA(double cm) {
	// N.B. this is only for 2D
	//cm =15.;
	
	// initial checks
	if (vEntries[0].position.GetNoElements() != 2) {
		std::cout << "Could not run SOSA - needs 2D positions" << std::endl;
		return;
	}
	
	// consts
	int N = vEntries.size();
	
	// find left-most entry
	int iZMin = 0;
	for (int i = 1; i < N; i++) {
		if (vEntries[i].position[1] < vEntries[iZMin].position[1]) {
			iZMin = i;
		}
	}
	
	// Put points into a graph that are less than cm (Specified Distance)
	std::vector<double> a; a.clear();
	std::vector<double> b; b.clear();
	for (int i = 0; i < N; i++) {
		if (vEntries[i].position[1] < vEntries[1].position[1] + cm) { 
			a.push_back(vEntries[i].position[1]);	// Z
			b.push_back(vEntries[i].position[0]);	// x/y
		}
	}
	TGraph* gr = new TGraph(a.size(), &a[0], &b[0]); // Create graph
	
	// BREAK THE FUNCTION IF NOT ENOUGH POINTS FOR A LINEAR FIT
	if (a.size() <= 3) {
		std::cout << "Not enough points for linear fit. Sk ipping..." << std::endl;
		clearDataEntries(false);
		return;
	}
	
	// Fit 2D line to these points - fit("pol1") "y = p1 * x + p0"
	gr->Fit("pol1", "Q");
	TF1 *fit = gr->GetFunction("pol1");
	double p0 = fit->GetParameter(0);
	double p1 = fit->GetParameter(1);
	
	double z0 = vEntries[iZMin].position[1];
	double x0 = p0 + p1*z0;


	z0 = vEntries[1].position[1]; // Redefined the x0 and z0 positions
	x0 = vEntries[1].position[0];
	
	
	//double ctheta = 1./std::sqrt(1. + std::abs(p1 * cm)/std::pow(cm - z0,2) ); // temp code for improved SOSA
	//double stheta = std::sqrt(1. - std::pow(ctheta,2) );

	//double test= (p1 * cm)/std::pow(cm - z0,2) ;

	//std::cout << "costheta: " << ctheta << "\nstheta:: "<< stheta  << "\np1: " << p1 <<std::endl;

	//if (p1 < 0.) stheta = stheta* -1.; // if the shower is pointing in the opposite direction then rotate the other way.

	//std::cout << "p0: " << p0<< "\np1: "<< p1 << "\nz0: "<< z0 <<"\ny0:  " << x0 << "\nvEntries[10].position[1]: " << vEntries[10].position[1] << "\nvEntries[10].position[0]: "  << vEntries[10].position[0]<< std::endl;

	// Then calculate perpendicular distances from this line
	for (int i = 0; i < N; i++) {
		double z = vEntries[i].position[1];
		double x = vEntries[i].position[0];
		double xp = (p0 + p1*z - x)/std::sqrt(1 + p1*p1);
		double zp = std::sqrt(std::pow(z-z0,2) + std::pow(x-x0,2) - std::pow(xp,2));
		vEntries[i].position[1] = zp;
		vEntries[i].position[0] = xp;
		//vEntries[i].position[1] = z * ctheta + x * stheta - z0 ; // z prime 
		//vEntries[i].position[0] = x * ctheta - z * stheta - x0;  // x prime

		vEntries[i].primInd = 1;
	}

	//std::cout << "\n\nCorrected\np0: " << p0<< "\np1: "<< p1 << "\nz0: "<< z0 <<"\ny0:  " << x0 << "\nvEntries[10].position[1]: " << vEntries[10].position[1] << "\nvEntries[10].position[0]: "  << vEntries[10].position[0]<< std::endl;
	
	// fill vector check
	vSOSA[0] = 1./std::sqrt(1. + p1*p1); // X
	vSOSA[1] = p1/std::sqrt(1. + p1*p1); // Z
	
	//std::cout << "Finished SOSA" << std::endl;
	
	return;
}

double MolRadReco::moliereRadius(double energySum) {

	int iNbins = hPerpDist->GetNbinsX(); // Gets the total number of x-bins for the histogram hPerpDist
	int iBinUpper = 0;
	double dIntegral = 0.;
	
	// Check if the integral of the charge agrees with the summed energy
	if (std::abs(1 - (hPerpDist->Integral(0, iNbins+1)/energySum)) < 0.001) { // calculate integral-to-total-energy ratio (include mean energy deposit energy to convert counts to energy)

		// Calculate Moliere Radius
		while (dIntegral < 0.9*energySum) {
			iBinUpper++;
			dIntegral = hPerpDist->Integral(0, iBinUpper);
		}
		// fill Mol Rad histogram
		// std::cout << "Calculated Moliere Radius: " << hPerpDist->GetBinLowEdge(iBinUpper) << std::endl;
		return hPerpDist->GetBinLowEdge(iBinUpper);

	} else {
		std::cout << "Integral and Counted energies do not agree (" << (hPerpDist->Integral(0, iNbins+1)/energySum) << ")" << std::endl;
		return -25.;	// debug value
	}
}

// Default constructor for MolradReco
MolRadReco::MolRadReco(fhicl::ParameterSet const & p): EDAnalyzer(p), fCalorimetryAlg(p.get<fhicl::ParameterSet>("CaloAlg")) {

	fSimulationProducerLabel = p.get< std::string >("SimulationLabel");
	fHitProducerLabel = p.get< std::vector< std::string > >("HitLabel");
	//fClusterParamsAlg = p.get<fhicl::ParameterSet>("ClusterAlg");
} 

// Function gets the truth x, y z and energy. Also returns the total Energy deposited
double MolRadReco::GetTruthXYZE(simChannelVec_t simChannelVec, bool use3D, int event){
	
	double dEnergyDepositedSum = 0.; // total amount of deposited energy

	// loop over channels
	for( simChannelVec_t::const_iterator channelPtr = simChannelVec.begin(); channelPtr != simChannelVec.end(); ++channelPtr ) {
		// get individual channel
		const sim::SimChannel& channel = *(*channelPtr);
		
		// select plane 0
		if ( fGeometry->SignalType(channel.Channel()) == geo::kCollection ) {
			// get time slice
			const sim::SimChannel::TDCIDEs_t& timeSlices = channel.TDCIDEMap();
			
			// loop over time slices
			for( sim::SimChannel::TDCIDEs_t::const_iterator timePtr = timeSlices.begin(); timePtr != timeSlices.end(); ++timePtr ) {
				
				// get vector of IDEs (second entry in map<first,second>)
				typedef std::vector<sim::IDE> depositVec_t;
				const depositVec_t& energyDeposits = (*timePtr).second;
				
				// loop over IDEs
				for( depositVec_t::const_iterator energyPtr = energyDeposits.begin(); energyPtr != energyDeposits.end(); ++energyPtr ) {
					// get IDE
					const sim::IDE& energyDeposit = (*energyPtr);
					TruthEnergyDeposits.push_back(energyDeposit.energy);
					TruthZPos.push_back(energyDeposit.z); // add z pos to a tree
					TruthXPos.push_back(energyDeposit.x); // add xpos to tree

					
					// Add hit coordinates to PCA vectors					
					
					if (use3D == true) {
						TVectorD vHitPos(3);
						vHitPos[0] = energyDeposit.x -25.;	// X
						vHitPos[1] = energyDeposit.y;	// Y
						vHitPos[2] = energyDeposit.z;	// Z
						addDataEntry(energyDeposit.energy, vHitPos); // Add the entries to the vector
						dEnergyDepositedSum += energyDeposit.energy; // calculate energy sum
						hTruePosition3D->Fill(vHitPos[0], vHitPos[1], vHitPos[2], energyDeposit.energy); // fill 3D PCA histogram

						
					
					} else { // 2D case
						
						TVectorD vHitPos(2);
						vHitPos[0] = energyDeposit.x -25. ;	// X
						vHitPos[1] = energyDeposit.z;	// Z
						addDataEntry(energyDeposit.energy, vHitPos); // Add the entries to the vector
						dEnergyDepositedSum += energyDeposit.energy; // calculate energy sum


						if (HistFill != event) { 
							hTruePosition2D->Fill(vHitPos[1], vHitPos[0], energyDeposit.energy);
						}
						
					}
							
				} // End loop over energy deposits (IDEs)


			} // End loop over Time slices

		} // End condition if in collection plane

	} // End loop over all channels
	HistFill = event; // Dont fill this histogram again
	return dEnergyDepositedSum; 
}


void MolRadReco::beginJob() {
	// Access ART's TFileService, which will handle histograms/trees/etc.
	art::ServiceHandle<art::TFileService> tfs;
	
	//(var, title, nxbins,xlow,xhigh,nybins,ylow,yhigh) TH2D Specifyer

	//dEdx Histogram
	hdEdxValues = tfs->make<TH1D>("dEdxValues","dEdx of Hits",60,0,25);	
	hdEdxValues->GetXaxis()->SetTitle("dEdx (Mev/cm)");
	hdEdxValues->GetYaxis()->SetTitle("Events");
	hdEdxValues->GetYaxis()->SetTitleOffset(1.15);

	// Energy Calibration scatter plot
	gECalScat = tfs->makeAndRegister<TGraph>("gECalScat", "EcalScat;dQdx [E/cm]; dEdx [MeV/cm]");
	gECalScat->SetMarkerStyle(kFullDotMedium);
	gECalScat->SetLineWidth(0);

	// Energy Calibration scatter plot
	TruthRecoScat = tfs->makeAndRegister<TGraph>("TruthRecoScat", "Truth Reco Scatter Plot;Truth Energy [MeV]; Reco Energy [MeV]");
	TruthRecoScat->SetMarkerStyle(kFullDotMedium);
	TruthRecoScat->SetMarkerSize(6);
	TruthRecoScat->SetLineWidth(0);

	// ***************************Energy Profile Plots*********************************
	// Notes: ROOT TMath has a gamma_pdf() function which can be used to fit the longitudinal distibution.


	// Energy profile No Algorithm
	hEnergyProfile = tfs->make<TH1D>("energyprofile","Energy Profile of Events",30,0.,100.);
	hEnergyProfile->GetXaxis()->SetTitle("Z (cm)");
	hEnergyProfile->GetYaxis()->SetTitle("Energy (MeV/cm)");
	
	//hEnergyProfile->SetOption("BAR");
	//hEnergyProfile->Sumw2(kFALSE);

	// Energy profile PCA RECO
	hEnergyProfilePCA = tfs->make<TH1D>("energyprofilePCA","Energy Profile of Events (PCA Axis)",100,0.,100.);
	hEnergyProfilePCA->GetXaxis()->SetTitle("Z (cm)");
	hEnergyProfilePCA->GetYaxis()->SetTitle("dEdx (MeV/cm)");


	// True Energy profile 
	hTrueEnergyProfile = tfs->make<TH1D>("trueenergyprofile","Energy Profile of Events (Truth)",125,0.,100.);
	hTrueEnergyProfile->GetXaxis()->SetTitle("Z (cm)");
	hTrueEnergyProfile->GetYaxis()->SetTitle("True dE [MeV]");

	//True energy profile in X direction
	hTrueEnergyProfileX = tfs->make<TH1D>("hTrueEnergyProfileX","Energy Profile of Events (Truth) in X Dir; X [cm]; True dE [MeV]",600,-50.,50.);
	
	hTrueEnergyProfileR = tfs->make<TH1D>("hTrueEnergyProfileR","Energy Profile of Events (Truth) in Radial Dir; r [cm]; True dE [MeV]",600,0.,35.);


	// ********************************************************************************

	// Reco-Truth energy scatter plot
 	hERecoTruthScat= tfs->make<TH2D>("ERecoTruthScat","Scatter Plot of Reco and Truth Energies (muons only) ",100,160.,400.,100,160.,400.);
	hERecoTruthScat->GetYaxis()->SetTitle("Reco Energy (Mev)");
	hERecoTruthScat->GetXaxis()->SetTitle("Truth Energy");
	hERecoTruthScat->SetOption("SCAT");


	hERecoTruthDiff = tfs->make<TH1D>("ERecoTruthDiff","Difference of Energy Truth minus Reco",200,-20.,100.);
	hERecoTruthDiff->GetXaxis()->SetTitle("Energy Difference (Mev)");
	hERecoTruthDiff->GetYaxis()->SetTitle("Frequency Density");

	
	hPosition2D = tfs->make<TH2D>("position2d","2D Position of Hits (Sum of all events)",200,0.,-5.,200,-10.,100.); 
	hPosition2D->GetXaxis()->SetTitle("Along Shower Axis (cm)");
	hPosition2D->GetYaxis()->SetTitle("Perpendicular to Shower Axis (cm)");
	hPosition2D->GetYaxis()->SetTitleOffset(1.15);
	
	hPosition2DSOSA = tfs->make<TH2D>("position2dsosa","2D Position of Hits with SOSA (Sum of all events)",200,0.,-5.,200,-10.,100.);
	hPosition2DSOSA->GetXaxis()->SetTitle("Along Shower Axis (cm)");
	hPosition2DSOSA->GetYaxis()->SetTitle("Perpendicular to Shower Axis (cm)");
	hPosition2DSOSA->GetYaxis()->SetTitleOffset(1.05);
	
	hPosition2DPCA = tfs->make<TH2D>("position2dpca","2D Position of Hits with PCA (Sum of all events)",200,0.,-5.,200,-10.,100.);
	hPosition2DPCA->GetXaxis()->SetTitle("Along Shower Axis (cm)");
	hPosition2DPCA->GetYaxis()->SetTitle("Perpendicular to Shower Axis (cm)");
	hPosition2DPCA->GetYaxis()->SetTitleOffset(1.15);
	
	hTruePosition3D = tfs->make<TH3D>("trueposition3d","3D Position of Energy Deposits (Sum of all events)",50,0.,45.,50,-20.,20., 50,0.,120.);
	hTruePosition3D->GetXaxis()->SetTitle("X (cm)");
	hTruePosition3D->GetYaxis()->SetTitle("Y (cm)");
	hTruePosition3D->GetZaxis()->SetTitle("Z (cm)");
	//hTruePosition3D->GetYaxis()->SetTitleOffset(1.15);
	
	hTruePosition3DPCA = tfs->make<TH3D>("trueposition3dpca","3D Position of Energy Deposits after PCA (Sum of all events)",50,-20.,20.,50,-20.,20.,50,-60.,60.);
	hTruePosition3DPCA->GetXaxis()->SetTitle("Perpendicular to shower axis X (cm)");
	hTruePosition3DPCA->GetYaxis()->SetTitle("Perpendicular to shower axis Y (cm)");
	hTruePosition3DPCA->GetZaxis()->SetTitle("Along shower axis (cm)");
	//hTruePosition3DPCA->GetYaxis()->SetTitleOffset(1.15);
	
	hTruePosition2D = tfs->make<TH2D>("trueposition2d","2D Position of Energy Deposits (Sum of all events)",50,0.,100.,50,-50.,50.);
	hTruePosition2D->GetXaxis()->SetTitle("Z (cm)");
	hTruePosition2D->GetYaxis()->SetTitle("X (cm)");
	hTruePosition2D->GetYaxis()->SetTitleOffset(1.15);
	
	hTruePosition2DSOSA = tfs->make<TH2D>("trueposition2dsosa","2D Position of Energy Deposits after SOSA (Sum of all events)",50,0.,100.,50,-25.,25.);
	hTruePosition2DSOSA->GetXaxis()->SetTitle("Along shower axis (cm)");
	hTruePosition2DSOSA->GetYaxis()->SetTitle("Perpendicular to shower axis (cm)");
	hTruePosition2DSOSA->GetYaxis()->SetTitleOffset(1.05);
	
	hTruePosition2DPCA = tfs->make<TH2D>("trueposition2dpca","2D Position of Energy Deposits after PCA (Sum of all events)",50,0.,100.,50,-25.,25.);
	hTruePosition2DPCA->GetXaxis()->SetTitle("Along shower axis (cm)");
	hTruePosition2DPCA->GetYaxis()->SetTitle("Perpendicular to shower axis (cm)");
	hTruePosition2DPCA->GetYaxis()->SetTitleOffset(1.15);
	
	hEnergyDetected = tfs->make<TH1D>("energydetected","Energy Detected in an Event",50,0.,-5.);
	hEnergyDetected->GetXaxis()->SetTitle("Energy (MeV)");
	hEnergyDetected->GetYaxis()->SetTitle("Frequency Density");
	hEnergyDetected->GetYaxis()->SetTitleOffset(1.1);
	
	
	hPerpDist = tfs->make<TH1D>("perpdist","Perpendicular Distance (should be empty)",700,0.,35.);
	hPerpDist->GetXaxis()->SetTitle("X Distance (cm)");
	hPerpDist->GetYaxis()->SetTitle("Frequency Density");
	hPerpDist->GetYaxis()->SetTitleOffset(1.05);

	hPerpDist_All = tfs->make<TH1D>("hPerpDist_All","Perpendicular Distance for all events(should be empty)",1000,0.,35.);


	hMolRadTruth2D = tfs->make<TH1D>("MoliereTruth2D","Moliere Radius Using Truth Information (Straight Only)",50,0.,-5.);
	hMolRadTruth2D->GetXaxis()->SetTitle("Moliere Radius (cm)");
	hMolRadTruth2D->GetYaxis()->SetTitle("Frequency Density");

	hMolRadTruth3D = tfs->make<TH1D>("MoliereTruth3D","Moliere Radius Using Truth Information (Straight Only)",50,0.,-5.);
	hMolRadTruth3D->GetXaxis()->SetTitle("Moliere Radius (cm)");
	hMolRadTruth3D->GetYaxis()->SetTitle("Frequency Density");

	hMolRadHitPCA = tfs->make<TH1D>("hitmoliereradiuspca","Moliere Radius Using Hit Information (PCA)",50,0.,-5.);
	hMolRadHitPCA->GetXaxis()->SetTitle("Moliere Radius (cm)");
	hMolRadHitPCA->GetYaxis()->SetTitle("Frequency Density");
	hMolRadHitPCA->GetYaxis()->SetTitleOffset(1.05);
	hMolRadHitPCA->SetFillColor(kAzure-4);
	
	hMolRadHitSOSA = tfs->make<TH1D>("hitmoliereradiussosa","Moliere Radius Using Hit Information (SOSA)",50,0.,-5.);
	hMolRadHitSOSA->GetXaxis()->SetTitle("Moliere Radius (cm)");
	hMolRadHitSOSA->GetYaxis()->SetTitle("Frequency Density");
	hMolRadHitSOSA->GetYaxis()->SetTitleOffset(1.05);
	hMolRadHitSOSA->SetFillColor(kAzure-4);
	
	hMolRadTruthPCA2D = tfs->make<TH1D>("truthmoliereradius2Dpca","Moliere Radius Using 2D Truth Information (PCA)",50,0.,-5.);
	hMolRadTruthPCA2D->GetXaxis()->SetTitle("Moliere Radius (cm)");
	hMolRadTruthPCA2D->GetYaxis()->SetTitle("Frequency Density");
	hMolRadTruthPCA2D->GetYaxis()->SetTitleOffset(1.05);
	hMolRadTruthPCA2D->SetFillColor(kAzure-4);
	
	hMolRadTruthSOSA2D = tfs->make<TH1D>("truthmoliereradius2Dsos","Moliere Radius Using 2D Truth Information (SOSA)",50,0.,-5.);
	hMolRadTruthSOSA2D->GetXaxis()->SetTitle("Moliere Radius (cm)");
	hMolRadTruthSOSA2D->GetYaxis()->SetTitle("Frequency Density");
	hMolRadTruthSOSA2D->GetYaxis()->SetTitleOffset(1.05);
	hMolRadTruthSOSA2D->SetFillColor(kAzure-4);
	
	hMolRadTruthPCA3D = tfs->make<TH1D>("truthmoliereradius3Dpca","Moliere Radius Using 3D Truth Information",50,0.,-5.);
	hMolRadTruthPCA3D->GetXaxis()->SetTitle("Moliere Radius (cm)");
	hMolRadTruthPCA3D->GetYaxis()->SetTitle("Frequency Density");
	hMolRadTruthPCA3D->GetYaxis()->SetTitleOffset(1.05);
	hMolRadTruthPCA3D->SetFillColor(kAzure-4);
	
	hMolRadCorrelation2Dh2Dt = tfs->make<TH2D>("molradcorrelation2dh2dt","2D Hit - 2D Truth Moliere Radius Correlation (PCA)",50,0.,20.,50,0.,20.);
	hMolRadCorrelation2Dh2Dt->GetXaxis()->SetTitle("2D Hit Moliere Radius (cm)");
	hMolRadCorrelation2Dh2Dt->GetYaxis()->SetTitle("2D Truth Moliere Radius (cm)");
	
	hMolRadCorrelation2Dh3DtPCA = tfs->make<TH2D>("molradcorrelation2dh3dtpca","2D Hit - 3D Truth Moliere Radius Correlation (PCA)",50,0.,20.,50,0.,20.);
	hMolRadCorrelation2Dh3DtPCA->GetXaxis()->SetTitle("2D Hit Moliere Radius (cm)");
	hMolRadCorrelation2Dh3DtPCA->GetYaxis()->SetTitle("3D Truth Moliere Radius (cm)");
	
	hMolRadCorrelation2Dh3DtSOSA = tfs->make<TH2D>("molradcorrelation2dh3dtsosa","2D Hit - 3D Truth Moliere Radius Correlation (SOSA)",50,0.,35.,50,0.,25.);
	hMolRadCorrelation2Dh3DtSOSA->GetXaxis()->SetTitle("2D Hit Moliere Radius (SOSA) (cm)");
	hMolRadCorrelation2Dh3DtSOSA->GetYaxis()->SetTitle("3D Truth Moliere Radius (Truth) (cm)");
	
	hMolRadCorrelation2Dt3Dt = tfs->make<TH2D>("molradcorrelation2dt3dt","2D Truth - 3D Truth Moliere Radius Correlation (PCA)",50,0.,20.,50,0.,20.);
	hMolRadCorrelation2Dt3Dt->GetXaxis()->SetTitle("2D Truth Moliere Radius (cm)");
	hMolRadCorrelation2Dt3Dt->GetYaxis()->SetTitle("3D Truth Moliere Radius (cm)");
	
	hMolRadCorrelationSOSA2Dh2Dt = tfs->make<TH2D>("molradcorrelationSOSA2dh2dt","2D Hit - 2D Truth Moliere Radius Correlation (SOSA)",50,0.,20.,50,0.,20.);
	hMolRadCorrelationSOSA2Dh2Dt->GetXaxis()->SetTitle("2D Hit Moliere Radius (cm)");
	hMolRadCorrelationSOSA2Dh2Dt->GetYaxis()->SetTitle("2D Truth Moliere Radius (cm)");

	hMolRadCorTruth = tfs->make<TH2D>("hMolRadCorrTruth","2D Truth - 3D Truth Moliere Radius Correlation (Straight Showers Only)",50,0.,20.,50,0.,25.);
	hMolRadCorTruth->GetXaxis()->SetTitle("2D Truth Moliere Radius (cm)");
	hMolRadCorTruth->GetYaxis()->SetTitle("3D Truth Moliere Radius (cm)");


	// 1D Correlation plots
	hCorr_2DReco_2DTruth_PCA = tfs->make<TH1D>("gCorr_2DReco_2DTruth_PCA", "2D Truth - 2D Reco PCA; Difference [cm]; Frequency",50,-10.,10.);
	hCorr_2DReco_2DTruth_SOSA = tfs->make<TH1D>("gCorr_2DReco_2DTruth_SOSA", "2D Truth - 2D Reco SOSA; Difference [cm]; Frequency",50,-10.,10.);

	
	// Energy Calibration scatter plot
	gCorr_2Dt_3Dt = tfs->makeAndRegister<TGraph>("gCorr_2Dt_3Dt", "2D Truth to 3D Truth Moliere Radius Scatter Plot; 2D Moliere Radius [cm]; 3D Moliere Radius [cm]");
	gCorr_2Dt_3Dt->SetMarkerStyle(kFullDotMedium);
	gCorr_2Dt_3Dt->SetMarkerSize(6);
	gCorr_2Dt_3Dt->SetLineWidth(0);
	
	hMolRadCorrelation2Dh2DtNorm = tfs->make<TH2D>("molradcorrelation2dh2dtnorm","2D Hit - 2D Truth Moliere Radius Correlation (PCA, Normalised)",50,0.,20.,50,0.,20.);
	hMolRadCorrelation2Dh2DtNorm->GetXaxis()->SetTitle("2D Hit Moliere Radius (cm)");
	hMolRadCorrelation2Dh2DtNorm->GetYaxis()->SetTitle("2D Truth Moliere Radius (cm)");
	
	hMolRadCorrelation2Dh3DtPCANorm = tfs->make<TH2D>("molradcorrelation2dh3dtpcanorm","2D Hit - 3D Truth Moliere Radius Correlation (PCA, Normalised)",50,0.,20.,50,0.,20.);
	hMolRadCorrelation2Dh3DtPCANorm->GetXaxis()->SetTitle("2D Hit Moliere Radius (cm)");
	hMolRadCorrelation2Dh3DtPCANorm->GetYaxis()->SetTitle("3D Truth Moliere Radius (cm)");
	
	hMolRadCorrelation2Dh3DtSOSANorm = tfs->make<TH2D>("molradcorrelation2dh3dtsosanorm","2D Hit - 3D Truth Moliere Radius Correlation (SOSA, Normalised)",50,0.,20.,50,0.,20.);
	hMolRadCorrelation2Dh3DtSOSANorm->GetXaxis()->SetTitle("2D Hit Moliere Radius (cm)");
	hMolRadCorrelation2Dh3DtSOSANorm->GetYaxis()->SetTitle("3D Truth Moliere Radius (cm)");
	
	hMolRadCorrelation2Dt3DtNorm = tfs->make<TH2D>("molradcorrelation2dt3dtnorm","2D Truth - 3D Truth Moliere Radius Correlation (PCA, Normalised)",50,0.,20.,50,0.,20.);
	hMolRadCorrelation2Dh2DtNorm->GetXaxis()->SetTitle("2D Truth Moliere Radius (cm)");
	hMolRadCorrelation2Dh2DtNorm->GetYaxis()->SetTitle("3D Truth Moliere Radius (cm)");
	
	hMolRadCorrelationSOSA2Dh2DtNorm = tfs->make<TH2D>("molradcorrelationsosa2dh2dtnorm","2D Hit - 2D Truth Moliere Radius Correlation (SOSA, Normalised)",50,0.,20.,50,0.,20.);
	hMolRadCorrelationSOSA2Dh2DtNorm->GetXaxis()->SetTitle("2D Hit Moliere Radius (cm)");
	hMolRadCorrelationSOSA2Dh2DtNorm->GetYaxis()->SetTitle("2D Truth Moliere Radius (cm)");
	
	hPCASOSAAngle = tfs->make<TH1D>("pcasosaangle","Angle between PCA and SOSA vectors",40,0.,-5.);
	hPCASOSAAngle->GetXaxis()->SetTitle("Angle (deg)");
	hPCASOSAAngle->GetYaxis()->SetTitle("Frequency Density");
	
	hEnergyFraction = tfs->make<TH1D>("energyfraction","Fraction of truth initial energy deposited",50,0.,1.);
	hEnergyFraction->GetXaxis()->SetTitle("Energy Fraction");
	hEnergyFraction->GetYaxis()->SetTitle("Frequency Density");
	
	hMolRadConvertedPCA = tfs->make<TH1D>("moliereradiusconvertedpca","Converted Moliere Radius (MC Hit Information, PCA)",50,0.,-5.);
	hMolRadConvertedPCA->GetXaxis()->SetTitle("Moliere Radius (cm)");
	hMolRadConvertedPCA->GetYaxis()->SetTitle("Frequency Density");
	hMolRadConvertedPCA->GetYaxis()->SetTitleOffset(1.05);
	hMolRadConvertedPCA->SetFillColor(kAzure-4);
	
	DataTree = tfs->make<TTree>("EventTree","EventTree"); // Create the TTree
	
	// Event Specific
	DataTree->Branch("run", &run);
	DataTree->Branch("subrun",&subrun);
    DataTree->Branch("event",&evt);
    
    //Truth
    DataTree->Branch("TruthEnergyDeposit", &TruthEnergyDeposits);
    DataTree->Branch("TruthZPos", &TruthZPos);
    DataTree->Branch("TruthXPos", &TruthXPos);

    // ####THESE BRANCHES NEED TO BR UPDATED WITH THE CORRECT VARAIBLE NAMES #########
    // Reconstructed
    //DataTree->Branch("Reco_E", &Reco_E);
    //DataTree->Branch("Reco_ZPos", &Reco_ZPos);
    //DataTree->Branch("Reco_XPos", &Reco_XPos);
    
    // PCA
    //DataTree->Branch("PCA_E", &PCA_E);
    //DataTree->Branch("PCA_ZPos", &PCA_ZPos);
    //DataTree->Branch("PCA_XPos", &PCA_XPos);

    PCA_E_Total = 0.;


	std::cout << "Starting job..." << std::endl;
}

// runs at the start
void MolRadReco::beginRun(art::Run const & r)
{
  // Implementation of optional member function here.
}

void MolRadReco::beginSubRun(art::SubRun const & sr)
{
  // Implementation of optional member function here.
}

// Analyser: runs once per event over all events
void MolRadReco::analyze(art::Event const & event)
{

	// Determine event ID
  	run = event.id().run();
    subrun = event.id().subRun();
    evt = event.id().event();
    
	bool bUseSOSA = true;
	fills+=1; // Add one to fills for rescaling energy profile	

	// hitHandle: Holds hit information
	art::Handle<std::vector<recob::Hit>> hitHandle; // Handle is a smart pointer
		
	// detprop: Detector Properties
	auto const* detprop = lar::providerFrom<detinfo::DetectorPropertiesService>();
	
	// event-specific histograms
	double dEnergySum = 0.;
	int vEntryFills = 0 ; // Number of fills to current vEntry 


	// loop over hit handles (chooses the right event number to run)
	for(std::vector<std::string>::const_iterator hhn = fHitProducerLabel.begin(); hhn != fHitProducerLabel.end(); ++hhn) { // hits are stored un fHitProducer Label for each event
		event.getByLabel(*hhn, hitHandle); // event comes from the input of the function and getByLabel grabs the info

		// if successful at getting hit handle
		if(!(hitHandle.failedToGet())) {
			
			// Loop over hits in said event 
			for(auto hit = hitHandle -> begin(); hit != hitHandle -> end(); ++hit) {
				
				// if hit is in collection plane
				if(fGeometry -> SignalType(hit -> Channel()) == geo::kCollection) {
					
					// Add hit coordinates to a vector
					geo::PlaneID plane_id = (hit -> WireID()).asPlaneID();

					TVectorD vHitPos(2);	// Create a vector of size 2 for storing the hits in the x and z coordinates
					// X [contains the stored hit positions]
					vHitPos[0] = detprop -> ConvertTicksToX((double) hit -> PeakTime(), plane_id) - 25.;
					
					// Z [contains the stored hit positions with a geometrical factor conversion for wire plane spacing ]
					// -263 for shifting channel
					vHitPos[1] = ((double) hit -> Channel()  - 263) * pitch; 
					
					//std::cout << "[0]: " <<vHitPos[0] << " [1]: "<<vHitPos[1] << std::endl;
					
					// ----------------------------------------------------------------------------------//
					// Make conversion of hits from ADC*Ticks to MeV/cm 
					
					double T0 = 0; // Initial start time
					double dEdx = 0; // In MeV/cm
					double dE = 0; 
					
					// Calls dEdx function and returns the conversion in MeV/cm based on area of hit
					dEdx = fCalorimetryAlg.dEdx_AREA(*hit,pitch, T0)  ; 

					// Add a condition that if the energy if greater than some val (in MeV/cm)
					// reconvert the high dEdx Values
					//if (dEdx > 2.5)	dEdx = hit->Integral() * 0.000977899 ; // constant calculated by hand on 200MeV el ECalScat Hist near start	
					
					// Look for unusually large dEdx values and replace with the previous value to correct
                    if(hit->Integral() > 3500){

						//std::cout << "dEdx abnormal  " << dEdx <<" dQdx: "<<hit->Integral()<<" event number:  "<< event.event()<<" hit, wire, time: " << hit->WireID().Wire  << " " << hit->PeakTime()  << std::endl;

						//dEdx = vEntries[vEntryFills-1].energy ; 
						
						// Use a modified calibration for dEdx
						dEdx = 0.000907293 * hit->Integral() + 0.00778931; 

						//std::cout << "Corrected E!: " << dEdx << std::endl;	
			
					}
				
					// ---------------------------------------------------------------------------------

					// Convert the dE/dx value to dE by multiplying by dx = 0.4mm/cos(60);
					dE = dEdx * pitch;
					
					// calculate energy sum
					dEnergySum += dE; // Sum of all hit energies

					//std::cout<< "dE = " << dE << std::endl;

					// creates a struct entry which contains the energy and vHitPos (Z,X positions of the hits)
					addDataEntry(dE, vHitPos);     

					// fill 2D PCA histogram
					// (Z,X,Energy) Shows a histogram of the x-z plane of all the showers combined
					hPosition2D -> Fill(vHitPos[1], vHitPos[0], dE); 

					// Fill the dEdx histogram  
					hdEdxValues -> Fill(dE);
					
					// Fil the scatter plot for dEdx vs Hit integral
					gECalScat -> SetPoint(vEntryFills, hit->Integral(),dEdx); 

					//std::cout<< "vHitPos[1]: "<< vHitPos[1] << "    Energy: " << dEdx << "    Wire: "<< << std::endl;
					
					vEntryFills ++; // Add one to the counter
					
					// Add parameters to a vector for a ttree
					if (event.event()==1){
						//Reco_E.push_back(dE);
						//Reco_XPos.push_back(vHitPos[0] - 25); // minus 25 to center on zero in the detector
						//Reco_ZPos.push_back(vHitPos[1]);
					}

				}// End condition if in collection plane

			} // End loop over all hits 

		} // End condition of failed hithandle

	} // End Loop over hit handles

	std::cout << "dEdx sum: " << dEnergySum << std::endl;

	double RecoEnergyTotal = dEnergySum ;
	PCA_E_Total+=dEnergySum; // Add to a number to get the total reconstructed energy of all events. 

	RecoEnergyVector.push_back(dEnergySum); // Add the reco energy to a vector

	int N = vEntries.size(); // Total size of vector
	
	// Make energy profile (not PCA or SOSA) for 1 event
	for (int i = 0; i < N; i++ ) {
		if (event.event() == 3) hEnergyProfile->Fill(vEntries[i].position[1], vEntries[i].energy); //Choose 1 event to look at the energy profile
		//hPerpDist_All->Fill(std::abs(vEntries[i].position[0]), vEntries[i].energy); // Moliere calculation for Reco data
	}

	// Run the PCA Algorithm
	runPCA(); // SWAPS THE BASIS VECTORS AROUND! position[0] is now Z... need to fix this
	
	//std::cout << "N =: "<< N << std::endl;
	for (int i = 0; i < N; i++) {
		// Fills a 2D hist for the Z and X coordinates with thier energy after PCA algorithm
		hPosition2DPCA->Fill(vEntries[i].position[vEntries[i].primInd], vEntries[i].position[(vEntries[i].primInd+1)%2], vEntries[i].energy); // (pos.[0],pos.[1],E) 
		//std::cout<< "vEntries[i].position[0]: "<< vEntries[i].position[0] << "    Energy: " << vEntries[i].energy <<  std::endl;

		//Used for calculating the moliere radius
		hPerpDist->Fill(std::abs(vEntries[i].position[(vEntries[i].primInd+1)%2]), vEntries[i].energy); // (abs(X),E) 

		//hPerpDist_All->Fill(std::abs(vEntries[i].position[1]), vEntries[i].energy); // Moliere calculation for Reco data
		
		
		// Fills histogram as a function of z and plots against energy
		if (event.event() == 2) hEnergyProfilePCA->Fill(vEntries[i].position[vEntries[i].primInd], vEntries[i].energy); 
	}
	 

	// clear PCA entries so can run again for SOSA algorithm
	clearDataEntries(false);
	
	// calculate moliere radius
	double dMolRad2DHitPCA = moliereRadius(dEnergySum);
	hMolRadHitPCA->Fill(dMolRad2DHitPCA); // Bins the moliere radius frequency density into a histogram
	hPerpDist->Reset(); 		          // Reset the variable for use with the SOSA algorithm 
	
	
	// **************************************** end PCA ****************************************
	// * ***************************************begin SOSA ****************************************
	
	
	// event-specific histograms
	dEnergySum = 0.;
	

	//### This is a copy and paste of the algorithm used for PCA 
	// loop over hit handles
	for(std::vector<std::string>::const_iterator hhn = fHitProducerLabel.begin(); hhn != fHitProducerLabel.end(); ++hhn) {
		event.getByLabel(*hhn, hitHandle);
		// if successful at getting hit handle
		if(!(hitHandle.failedToGet())) {
			// loop over hits
			for(auto hit = hitHandle->begin(); hit != hitHandle->end(); ++hit) {
				// if hit is in collection plane
				if(fGeometry->SignalType(hit->Channel()) == geo::kCollection) {
					// add hit coordinates to PCA vectors
					TVectorD vHitPos(2);
					geo::PlaneID plane_id = (hit->WireID()).asPlaneID();
					vHitPos[0] = detprop->ConvertTicksToX((double) hit -> PeakTime(), plane_id);	// X
					vHitPos[1] = ((double) hit -> Channel()  - 263) * pitch; 
					// Make conversion of hits from ADC*Ticks to MeV/cm 
					
					double T0 = 0; // Initial start time
					double dEdx = 0; // In MeV/cm
					double dE = 0; 
					
					// Calls dEdx function and returns the conversion in MeV/cm based on area of hit
					dEdx = fCalorimetryAlg.dEdx_AREA(*hit,pitch, T0)  ; 	
					// Look for unusually large dEdx values and replace with the previous value to correct
                    if(hit->Integral() > 3500){
						// Use a modified calibration for dEdx
						dEdx = 0.000907293 * hit->Integral() + 0.00778931; 
					}

					// Convert the dE/dx value to dE by multiplying by dx = 0.4mm/cos(60);
					dE = dEdx * pitch;
					
					// calculate energy sum
					dEnergySum += dE; // Sum of all hit energies

					// creates a struct entry which contains the energy and vHitPos (Z,X positions of the hits)
					addDataEntry(dE, vHitPos);     

				}
			}
		}
	}
	
	// Run the SOSA algorithm
	runSOSA(30.); // Enter the length of track to align up to was 30.
	
	N = vEntries.size();
	double dMolRad2DHitSOSA = 0.;
	
	if (N != 0) {
		//std::cout << N << std::endl;
		for (int i = 0; i < N; i++) {
			// Fills a 2D hist for the Z and X coordinates with thier energy after SOSA algorithm
			hPosition2DSOSA->Fill(vEntries[i].position[vEntries[i].primInd], vEntries[i].position[(vEntries[i].primInd+1)%2], vEntries[i].energy);  
			// Used for calculating the moliere radius
			hPerpDist->Fill(std::abs(vEntries[i].position[(vEntries[i].primInd+1)%2]), vEntries[i].energy); 
			//hEnergyProfile->Fill(vEntries[i].position[vEntries[i].primInd], vEntries[i].energy); // plot the SOSA energy profile

			//hPerpDist_All->Fill(std::abs(vEntries[i].position[0]), vEntries[i].energy); // Moliere calculation for Reco data
		}
		
		// clear SOSA entries
		clearDataEntries(false);
		
		// calculate moliere radius
		dMolRad2DHitSOSA = moliereRadius(dEnergySum);
		hMolRadHitSOSA->Fill(dMolRad2DHitSOSA);
		hPerpDist->Reset();
	} else {
		bUseSOSA = false;
	}
	
	// **************** END RECO CALCULATIONS *****************************
	
	// **************** BEGIN TRUTH CALCULATIONS *********************
	
	// create vector of simulated channels
	//typedef std::vector<const sim::SimChannel*> simChannelVec_t; //Alias for a type name
	simChannelVec_t simChannelVec; // Decalre simChannleVec as a simChannelVec type
	event.getView(fSimulationProducerLabel, simChannelVec);
	
	// create vector of particles involved in event
	art::Handle< std::vector<simb::MCParticle> > particleHandle;
	event.getByLabel(fSimulationProducerLabel, particleHandle);
	
	double dEnergyInitial = 0.;
	// find primary particle to get initial truth energy
	for(std::vector<simb::MCParticle>::const_iterator particlePtr = particleHandle->begin(); particlePtr != particleHandle->end(); ++particlePtr) {
		const simb::MCParticle& particle = (*particlePtr); // De-reference the particle pointer
		if (particle.Process() == "primary") {	           // if particle is primary
			dEnergyInitial += particle.Momentum(0).E()*1000.;	// initial energy (adds together over all primary particles)
		}
	}
	




	// *** *************BEGIN 2D PCA <Truth> *****************************
	dEnergyDepositedSum = GetTruthXYZE(simChannelVec, false, event.event()); // Get the Truth X, Y Z and Energy for the event
	DataTree->Fill(); // Fill the ttree



	// Calculate the moliere radius for Truth in 2D without alignment, This only makes sense for straight projected showers. 
	for (unsigned int i = 0; i < vEntries.size(); i++) { // fill the perp dist histogram
		hPerpDist->Fill(std::abs(vEntries[i].position[(vEntries[i].primInd+1)%2]), vEntries[i].energy); // abs(x), E
		hTrueEnergyProfileX->Fill(vEntries[i].position[0] , vEntries[i].energy); // Fill the truth energy profile histogram for the x direction. uncorrected now
	}
	double dMolRad2DTruth = moliereRadius(dEnergyDepositedSum); // Calculate the moliere radius
	std::cout << "MolRad2D Truth\t" << dMolRad2DTruth << std::endl;
	hMolRadTruth2D->Fill(dMolRad2DTruth);

	hPerpDist->Reset();

	// run PCA
	runPCA();
	
	N = vEntries.size();
	//std::cout << N << std::endl;
	for (int i = 0; i < N; i++) {
		hTruePosition2DPCA->Fill(vEntries[i].position[vEntries[i].primInd], vEntries[i].position[(vEntries[i].primInd+1)%2], vEntries[i].energy);
		hPerpDist->Fill(std::abs(vEntries[i].position[(vEntries[i].primInd+1)%2]), vEntries[i].energy);
		hTrueEnergyProfile->Fill(vEntries[i].position[vEntries[i].primInd], vEntries[i].energy); // Fill the truth energy profile hostogram
		hPerpDist_All->Fill(std::abs(vEntries[i].position[1]), vEntries[i].energy); // Moliere radius calculation for all events
	}
	
	// clear PCA entries
	clearDataEntries(false);
	
	// calculate moliere radius
	double dMolRad2DTruthPCA = moliereRadius(dEnergyDepositedSum);

		

	hMolRadTruthPCA2D->Fill(dMolRad2DTruthPCA);
	hPerpDist->Reset();
	
	
	
	// *************************** end 2D truth PCA ***************************
	// *************************** start 2D truth SOSA ***************************
	
	
	dEnergyDepositedSum = 0. ; // Re-Initialize
	
	// Get the Truth X, Y Z and Energy for the event
	dEnergyDepositedSum = GetTruthXYZE(simChannelVec, false, event.event()); 
	
	
	// run SOSA Algorithm
	runSOSA(30.);
	
	N = vEntries.size();
	double dMolRad2DTruthSOSA = 0.;
	
	if (N != 0) {
		//std::cout << N << std::endl;
		for (int i = 0; i < N; i++) {
		      //std::cout << " " << vEntries[i].position[1] << " " <<  vEntries[i].position[0] << std::endl;
			hTruePosition2DSOSA->Fill(vEntries[i].position[1], vEntries[i].position[0], vEntries[i].energy);
			hPerpDist->Fill(std::abs(vEntries[i].position[0]), vEntries[i].energy); // fills histogram with transverse distance of each energy deposit weighted by the energy
			//hTotalXDist->Fill(std::abs(vEntries[i].position[(vEntries[i].primInd+1)%2]), vEntries[i].energy);
			//hEnergyProfile->Fill(vEntries[i].position[vEntries[i].primInd], vEntries[i].energy);
			
		}
		
		// Fill Total Truth energy detected
		hEnergyDetected->Fill(dEnergyDepositedSum);
		std::cout<< "TruthEnergyTotal: " << dEnergyDepositedSum <<  std::endl;	

		// Fill the Reco - Truth Hist
		hERecoTruthScat->Fill(RecoEnergyTotal, dEnergyDepositedSum);
		
		// Fill the energy reco-truth difference histogram
		hERecoTruthDiff->Fill(dEnergyDepositedSum - RecoEnergyTotal); 


		// clear PCA entries
		clearDataEntries(false);
		
		// calculate moliere radius
		dMolRad2DTruthSOSA = moliereRadius(dEnergyDepositedSum);
		hMolRadTruthSOSA2D->Fill(dMolRad2DTruthSOSA);
		hPerpDist->Reset();
	} else {
		bUseSOSA = false;
	}
	
	
	hPCASOSAAngle->Fill(180.*std::acos(vSOSA[0]*vPCA[0] + vSOSA[1]*vPCA[1])/PI);
	
	// ***************************** END 2D SOSA ******************************************
	// ******************* *** BEGIN 3D PCA *****************************
	
	dEnergyDepositedSum = 0. ; // Re-Initialize
	dEnergyDepositedSum = GetTruthXYZE(simChannelVec, true, event.event()); // Get the Truth X, Y Z and Energy for the event
	TruthEnergyVector.push_back(dEnergyDepositedSum); // Add the Truth energy to a vector

	// Calculate the moliere radius for Truth in 2D without alignment, This only makes sense for straight projected showers. 
	for (unsigned int i = 0; i < vEntries.size(); i++) { // fill the perp dist histogram
		hPerpDist->Fill(std::sqrt(std::pow(vEntries[i].position[0], 2) + std::pow(vEntries[i].position[1], 2)), vEntries[i].energy); // abs(sqrt(x^2 + y^2), E
		hTrueEnergyProfileR->Fill(std::sqrt( std::pow(vEntries[i].position[0] ,2) + std::pow(vEntries[i].position[1] ,2) )   , vEntries[i].energy); // Fill the truth energy profile histogram for the radial direction. uncorrected now
		//hPerpDist_All->Fill(std::sqrt(std::pow(vEntries[i].position[0] - 25., 2) + std::pow(vEntries[i].position[1], 2)), vEntries[i].energy); // Moliere radius calculation for all events
	}

	double dMolRad3DTruth = moliereRadius(dEnergyDepositedSum); // Calculate the moliere radius
	std::cout << "MolRad3D Truth\t" << dMolRad3DTruth << std::endl;

	hMolRadTruth3D->Fill(dMolRad3DTruth);		

	hPerpDist->Reset();

	// Run PCA Algorithm
	runPCA();
	
	N = vEntries.size();
	//std::cout << N << std::endl;
	for (int i = 0; i < N; i++) {
		hTruePosition3DPCA->Fill(vEntries[i].position[(vEntries[i].primInd+1)%3], vEntries[i].position[(vEntries[i].primInd+2)%3], vEntries[i].position[vEntries[i].primInd], vEntries[i].energy);
		hPerpDist->Fill(std::sqrt(std::pow(vEntries[i].position[(vEntries[i].primInd+1)%3], 2) + std::pow(vEntries[i].position[(vEntries[i].primInd+2)%3], 2)), vEntries[i].energy);
		//hTrueEnergyProfile->Fill(vEntries[i].position[vEntries[i].primInd], vEntries[i].energy);
		//hPerpDist_All->Fill(std::sqrt(std::pow(vEntries[i].position[(vEntries[i].primInd+1)%3], 2) + std::pow(vEntries[i].position[(vEntries[i].primInd+2)%3], 2)), vEntries[i].energy);// Moliere radius calculation for all events
		
	}
	
	// clear PCA entries
	clearDataEntries(false);
	
	// calculate moliere radius
	double dMolRad3DTruthPCA = moliereRadius(dEnergyDepositedSum);



	hMolRadTruthPCA3D->Fill(dMolRad3DTruthPCA);
	hPerpDist->Reset(); 
	

	//*******************************************************************
	
	// Test Histograms
	//std::cout << hTrueRadialDist3D.Integral(0, iNbins + 1)/dEnergyInitial << std::endl;
	hEnergyFraction->Fill(dEnergyDepositedSum/dEnergyInitial);
	
	// Fill correlation histograms
	hMolRadCorrelation2Dh2Dt->Fill(dMolRad2DHitPCA, dMolRad2DTruthPCA); // changed PCA TO SOSA
	hMolRadCorrelation2Dh3DtPCA->Fill(dMolRad2DHitPCA, dMolRad3DTruthPCA);
	hMolRadCorrelation2Dh3DtSOSA->Fill(dMolRad2DHitSOSA, dMolRad3DTruth); // there's no 3D sosa in this code :/ this will only work for straight showers
	hMolRadCorrelation2Dt3Dt->Fill(dMolRad2DTruthPCA, dMolRad3DTruthPCA);
	gCorr_2Dt_3Dt-> SetPoint(event.event(),dMolRad2DTruth,dMolRad3DTruth);
	hMolRadCorTruth->Fill(dMolRad2DTruth, dMolRad3DTruth);
	if (bUseSOSA) hMolRadCorrelationSOSA2Dh2Dt->Fill(dMolRad2DHitSOSA, dMolRad2DTruthSOSA);

	hCorr_2DReco_2DTruth_PCA->Fill(dMolRad2DTruth -  dMolRad2DHitPCA );
	hCorr_2DReco_2DTruth_SOSA->Fill(dMolRad2DTruth -  dMolRad2DHitSOSA );

	
	// Fill converted moliere radius histogram
	// define final correlation fit here (R_M = P1*r_M + P0)
	double P0 = -5.841; // If you want uncontained aprox use P0 = 0.119 and P1 = 1.753
	double P1 = 4.325;
	hMolRadConvertedPCA->Fill(dMolRad2DHitPCA*P1 + P0);
	
	 
}

//runs at the end once
void MolRadReco::endJob()
{
	// Normalize Histograms

	// Loop over all y bins
	for (int j = 1; j <= hMolRadCorrelation2Dh2Dt->GetNbinsY(); j++) { 
		double iYCount = 0; // Total value in each row, reset every loop
		
		// Loop over all x bins in a bin y
		for (int i = 1; i <= hMolRadCorrelation2Dh2Dt->GetNbinsX(); i++) { 
			iYCount += (double) hMolRadCorrelation2Dh2Dt->GetBinContent(i, j);
		}
		
		// Divide each element in row by the total value in the row. 
		for (int i = 1; i <= hMolRadCorrelation2Dh2Dt->GetNbinsX(); i++) {
			if (iYCount != 0.) {
				hMolRadCorrelation2Dh2DtNorm->SetBinContent(i, j, hMolRadCorrelation2Dh2Dt->GetBinContent(i, j) / iYCount); 
			}
		}
	}

	for (int j = 1; j <= hMolRadCorrelation2Dh3DtPCA->GetNbinsY(); j++) {
		double iYCount = 0;
		for (int i = 1; i <= hMolRadCorrelation2Dh3DtPCA->GetNbinsX(); i++) {
			iYCount += (double) hMolRadCorrelation2Dh3DtPCA->GetBinContent(i, j);
		}
		for (int i = 1; i <= hMolRadCorrelation2Dh3DtPCA->GetNbinsX(); i++) {
			if (iYCount != 0.) {
				hMolRadCorrelation2Dh3DtPCANorm->SetBinContent(i, j, hMolRadCorrelation2Dh3DtPCA->GetBinContent(i, j) / iYCount);
			}
		}
	}

	for (int j = 1; j <= hMolRadCorrelation2Dh3DtSOSA->GetNbinsY(); j++) {
		double iYCount = 0;
		for (int i = 1; i <= hMolRadCorrelation2Dh3DtSOSA->GetNbinsX(); i++) {
			iYCount += (double) hMolRadCorrelation2Dh3DtSOSA->GetBinContent(i, j);
		}
		for (int i = 1; i <= hMolRadCorrelation2Dh3DtSOSA->GetNbinsX(); i++) {
			if (iYCount != 0.) {
				hMolRadCorrelation2Dh3DtSOSANorm->SetBinContent(i, j, hMolRadCorrelation2Dh3DtSOSA->GetBinContent(i, j) / iYCount);
			}
		}
	}

	for (int j = 1; j <= hMolRadCorrelation2Dt3Dt->GetNbinsY(); j++) {
		double iYCount = 0;
		for (int i = 1; i <= hMolRadCorrelation2Dt3Dt->GetNbinsX(); i++) {
			iYCount += (double) hMolRadCorrelation2Dt3Dt->GetBinContent(i, j);
		}
		for (int i = 1; i <= hMolRadCorrelation2Dt3Dt->GetNbinsX(); i++) {
			if (iYCount != 0.) {
				hMolRadCorrelation2Dt3DtNorm->SetBinContent(i, j, hMolRadCorrelation2Dt3Dt->GetBinContent(i, j) / iYCount);
			}
		}
	}

	for (int j = 1; j <= hMolRadCorrelationSOSA2Dh2Dt->GetNbinsY(); j++) {
		double iYCount = 0;
		for (int i = 1; i <= hMolRadCorrelationSOSA2Dh2Dt->GetNbinsX(); i++) {
			iYCount += (double) hMolRadCorrelationSOSA2Dh2Dt->GetBinContent(i, j);
		}
		for (int i = 1; i <= hMolRadCorrelationSOSA2Dh2Dt->GetNbinsX(); i++) {
			if (iYCount != 0.) {
				hMolRadCorrelationSOSA2Dh2DtNorm->SetBinContent(i, j, hMolRadCorrelationSOSA2Dh2Dt->GetBinContent(i, j) / iYCount);
			}
		}
	}
	
	// Fit the ECalScat graph
	gECalScat->Fit("pol1", "","", 0, 3500);
	ECalScatFit = gECalScat->GetFunction("pol1");
	double p0 = ECalScatFit->GetParameter(0);
	double p1 = ECalScatFit->GetParameter(1);

	std::cout <<"ENERGY FIT PARAMETERS  " << "P0: " << p0 << "    P1: " << p1 << std::endl;

	// Fit the Reco-Truth Difference plot
	hERecoTruthDiff -> Fit("gaus", "","");
	ECalScatFit = hERecoTruthDiff->GetFunction("gaus");
	double meanECalScatFit = ECalScatFit->GetParameter("Mean"); 
	
	//Rescale the dEdx Histogram by the area
	hdEdxValues->Scale(1./hdEdxValues->Integral());
	hdEdxValues->Sumw2(kFALSE);

	// Rescale the histogram by the number of fills (entries)
	std::cout << "Integral = "<< hEnergyProfile -> GetEntries() << std::endl; // Output the number of entries 
	
	// Scale the PCA Energy Profile
	//hEnergyProfilePCA->Scale(1./fills);	

	std::cout << "Integral reco "<< hEnergyProfile -> Integral("width") << std::endl; // Output the number of entries 


	// True energy profile normalised
	//double scale = hTrueEnergyProfile->GetBinContent(hTrueEnergyProfile->GetMaximumBin()); // Scale by the max bin value
	//hTrueEnergyProfile->Scale (1./scale);
	Truth_E_Total+=hTrueEnergyProfile -> Integral();
	hTrueEnergyProfile->Scale (1./fills);
	std::cout << "IntegralTrue= "<< hTrueEnergyProfile -> Integral() << std::endl; // Output the number of entries 
	

	// Normalise reco Energy profile
	//scale = hEnergyProfile->GetBinContent(hEnergyProfile->GetMaximumBin()); // Scale by the max bin value
	// hEnergyProfile -> Scale(1./scale);

	//scale = hEnergyProfilePCA->GetBinContent(hEnergyProfilePCA->GetMaximumBin());
	//hEnergyProfilePCA -> Scale(1./scale);


	// Make a plot of truth energy vs reco-energy+fit
	meanECalScatFit = 0; // Delete this if you want a correction
	for (size_t k = 0; k < RecoEnergyVector.size(); k++){
		TruthRecoScat->SetPoint(k, TruthEnergyVector[k],RecoEnergyVector[k] + meanECalScatFit ); 
	}

	TruthRecoScat->Fit("pol1","");
	TruthRecoScatFit = TruthRecoScat->GetFunction("pol1");


	// **************************Calculate the moliere radius for multiple showers.  ***********************
	int iNbins = hPerpDist_All->GetNbinsX(); // Gets the total number of x-bins for the histogram hPerpDist
	int iBinUpper = 0;
	double dIntegral = 0.;
	double E_total = Truth_E_Total; // Define for truth or reco moliere radius Truth_E_Total for Truth

	std::cout<<"Total ENERGY: " << E_total << std::endl;

	
	// Check if the integral of the charge agrees with the summed energy
	if (std::abs(1 - (hPerpDist_All->Integral(0, iNbins+1)/E_total)) < 0.001) { // calculate integral-to-total-energy ratio (include mean energy deposit energy to convert counts to energy)

		// Calculate Moliere Radius
		while (dIntegral < 0.9*E_total) {
			iBinUpper++;
			dIntegral = hPerpDist_All->Integral(0, iBinUpper);
		}
		std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n" << std::endl;
		std::cout << "Moliere Radius for all events: " << hPerpDist_All->GetBinLowEdge(iBinUpper)<< std::endl;
		std::cout << "\n\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" << std::endl;
	} else {
		std::cout << "Integral and Counted energies do not agree (" << (hPerpDist_All->Integral(0, iNbins+1)/E_total) << ")" << std::endl;
	}

	//hPerpDist_All->Reset();  // Reset hist for another calculation.


	// Fit the Radial Energy Profile
	hTrueEnergyProfileR->Scale(1./hTrueEnergyProfileR->GetBinContent(hTrueEnergyProfileR->GetMaximumBin())); // Scale by the max bin number

	hTrueEnergyProfileR->Fit("TProfFit_Radial","R");
	TProfFit = hTrueEnergyProfileR->GetFunction("TProfFit_Radial");




	// Define and fit the transverse energy profile.
	// Set fit parameter limits
    //float par0LowLimit = 3000.0,   par0UpLimit = 20000.0; // Limit for area0
    //float par1LowLimit =    -0.,   par1UpLimit =      0.; // Limit for mean1
    //float par2LowLimit =    0.8,   par2UpLimit =      1.1; // Limit for sigma1

    //float par3LowLimit =   1000.,   par3UpLimit =  3000.0; // Limit for area2
    //float par4LowLimit =    -0.,   par4UpLimit =      0.; // Limit for mean2
    //float par5LowLimit =    0.5,   par5UpLimit =      7.; // Limit for sigma2
	//hTrueEnergyProfileX->Scale(1./hTrueEnergyProfileX->GetBinContent(hTrueEnergyProfileX->GetMaximumBin())); // Scale by the max bin number
	

	// Lorenzian Parameters
    float par0LowLimit =  1e-4,   par0UpLimit =     0.1; // Limit for Width
    float par1LowLimit =  1e-7,   par1UpLimit =    0.01; // Limit for Scale
    float par2LowLimit =  1e-4,   par2UpLimit =    1e-2; // Limit for Amp
    float par3LowLimit =  -0.5,   par3UpLimit =     0.5; // Limit for Mean

    // Gaussian Parameters
    float par4LowLimit =    0.1,   par4UpLimit =      1.1; // Limit for amp2
    float par5LowLimit =     0.,   par5UpLimit =       0.; // Limit for mean2
    float par6LowLimit =   0.01,   par6UpLimit =      0.3; // Limit for Sigma2


	//TProfFit-> SetParNames("amp1", "mean1", "sigma1","amp2", "mean2", "sigma2");
	TProfFit-> SetParNames("Width", "Scale", "Amp", "Mean","Amp_Gaus", "Mean_Gaus", "Sigma_Gaus");
	
	// Set the Parameter limits
	TProfFit -> SetParLimits(0,  par0LowLimit,  par0UpLimit);
    TProfFit -> SetParLimits(1,  par1LowLimit,  par1UpLimit);
    TProfFit -> SetParLimits(2,  par2LowLimit,  par2UpLimit);
    TProfFit -> SetParLimits(3,  par3LowLimit,  par3UpLimit);
    TProfFit -> SetParLimits(4,  par4LowLimit,  par4UpLimit);
    TProfFit -> SetParLimits(5,  par5LowLimit,  par5UpLimit);
    TProfFit -> SetParLimits(6,  par6LowLimit,  par6UpLimit);
	
	hTrueEnergyProfileX->Fit("TProfFit","R");
	TProfFit = hTrueEnergyProfileX->GetFunction("TProfFit");



	// Calculate moliere radius based on the transverse profile x or radial.
	// NOTE CHANGE xmin if changing h
	TH1D* h = hTrueEnergyProfileR; //choose histogram

	TAxis *axis = h->GetXaxis();
	int bmin = 0 ;
	int bmax = 0 ;
	double integral_range = 0;
	double integral_total = h ->Integral();
	double xmin = 0;
	double xmax = 0;

	double integralimit = 17.0;


	// NOTE CHANGE xmin if changing h
	for (double k = 0; k < integralimit; k+=0.01){
	//xmin = -1 * k;
	xmin =0;
	xmax = k ;

	bmin = axis->FindBin(xmin); 
	bmax = axis->FindBin(xmax); 


	integral_range = h->Integral(bmin,bmax);
	integral_range -= h->GetBinContent(bmin) * ( xmin - axis->GetBinLowEdge(bmin) ) / axis->GetBinWidth(bmin);
	integral_range -= h->GetBinContent(bmax) * ( axis->GetBinUpEdge(bmax)- xmax) / axis->GetBinWidth(bmax);

	if (integral_range >= 0.9*integral_total) break; 

	std::cout << "Integral range = " << integral_range << "\t Total Integral = " << integral_total << "\tx = " << k << std::endl;

	if (k == integralimit) std::cout <<  "REACHED LIMIT OF RANGE" << std::endl;

	}
  



	clearDataEntries(true); // clear the tree variables

}

void MolRadReco::endRun(art::Run const & r)
{
  // Implementation of optional member function here.
}

void MolRadReco::endSubRun(art::SubRun const & sr)
{
  // Implementation of optional member function here.
}



DEFINE_ART_MODULE(MolRadReco)